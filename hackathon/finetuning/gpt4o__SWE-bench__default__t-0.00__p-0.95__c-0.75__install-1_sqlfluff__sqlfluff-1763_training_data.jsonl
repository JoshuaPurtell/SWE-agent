{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': 'We\'re currently solving the following issue within our repository. Here\'s the issue text:\nISSUE:\ndbt postgres fix command errors with UnicodeEncodeError and also wipes the .sql file\n_If this is a parsing or linting issue, please include a minimal SQL example which reproduces the issue, along with the `sqlfluff parse` output, `sqlfluff lint` output and `sqlfluff fix` output when relevant._\r\n\r\n## Expected Behaviour\r\nViolation failure notice at a minimum, without wiping the file. Would like a way to ignore the known error at a minimum as --noqa is not getting past this. Actually would expect --noqa to totally ignore this.\r\n\r\n## Observed Behaviour\r\nReported error: `UnicodeEncodeError: \'charmap\' codec can\'t encode character \'\\u2192\' in position 120: character maps to <undefined>`\r\n\r\n## Steps to Reproduce\r\nSQL file:\r\n```sql\r\nSELECT\r\n    reacted_table_name_right.descendant_id AS category_id,\r\n    string_agg(redacted_table_name_left.name, \' â†’ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\r\nFROM {{ ref2(\'redacted_schema_name\', \'redacted_table_name_left\') }} AS redacted_table_name_left\r\nINNER JOIN {{ ref2(\'redacted_schema_name\', \'reacted_table_name_right\') }} AS reacted_table_name_right\r\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\r\nGROUP BY reacted_table_name_right.descendant_id\r\n```\r\nRunning `sqlfluff fix --ignore templating,parsing,lexing -vvvv` and accepting proposed fixes for linting violations.\r\n\r\n## Dialect\r\n`postgres`, with `dbt` templater\r\n\r\n## Version\r\n`python 3.7.12`\r\n`sqlfluff 0.7.0`\r\n`sqlfluff-templater-dbt 0.7.0`\r\n\r\n## Configuration\r\nI\'ve tried a few, here\'s one:\r\n```\r\n[sqlfluff]\r\nverbose = 2\r\ndialect = postgres\r\ntemplater = dbt\r\nexclude_rules = None\r\noutput_line_length = 80\r\nrunaway_limit = 10\r\nignore_templated_areas = True\r\nprocesses = 3\r\n# Comma separated list of file extensions to lint.\r\n\r\n# NB: This config will only apply in the root folder.\r\nsql_file_exts = .sql\r\n\r\n[sqlfluff:indentation]\r\nindented_joins = False\r\nindented_using_on = True\r\ntemplate_blocks_indent = True\r\n\r\n[sqlfluff:templater]\r\nunwrap_wrapped_queries = True\r\n\r\n[sqlfluff:templater:jinja]\r\napply_dbt_builtins = True\r\n\r\n[sqlfluff:templater:jinja:macros]\r\n# Macros provided as builtins for dbt projects\r\ndbt_ref = {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}\r\ndbt_source = {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}\r\ndbt_config = {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}\r\ndbt_var = {% macro var(variable, default=\'\') %}item{% endmacro %}\r\ndbt_is_incremental = {% macro is_incremental() %}True{% endmacro %}\r\n\r\n# Common config across rules\r\n[sqlfluff:rules]\r\ntab_space_size = 4\r\nindent_unit = space\r\nsingle_table_references = consistent\r\nunquoted_identifiers_policy = all\r\n\r\n# L001 - Remove trailing whitespace (fix)\r\n# L002 - Single section of whitespace should not contain both tabs and spaces (fix)\r\n# L003 - Keep consistent indentation (fix)\r\n# L004 - We use 4 spaces for indentation just for completeness (fix)\r\n# L005 - Remove space before commas (fix)\r\n# L006 - Operators (+, -, *, /) will be wrapped by a single space each side (fix)\r\n\r\n# L007 - Operators should not be at the end of a line\r\n[sqlfluff:rules:L007]  # Keywords\r\noperator_new_lines = after\r\n\r\n# L008 - Always use a single whitespace after a comma (fix)\r\n# L009 - Files will always end with a trailing newline\r\n\r\n# L010 - All keywords will use full upper case (fix)\r\n[sqlfluff:rules:L010]  # Keywords\r\ncapitalisation_policy = upper\r\n\r\n# L011 - Always explicitly alias tables (fix)\r\n[sqlfluff:rules:L011]  # Aliasing\r\naliasing = explicit\r\n\r\n# L012 - Do not have to explicitly alias all columns\r\n[sqlfluff:rules:L012]  # Aliasing\r\naliasing = explicit\r\n\r\n# L013 - Always explicitly alias a column with an expression in it (fix)\r\n[sqlfluff:rules:L013]  # Aliasing\r\nallow_scalar = False\r\n\r\n# L014 - Always user full lower case for \'quoted identifiers\' -> column refs. without an alias (fix)\r\n[sqlfluff:rules:L014]  # Unquoted identifiers\r\nextended_capitalisation_policy = lower\r\n\r\n# L015 - Always remove parenthesis when using DISTINCT to be clear that DISTINCT applies to all columns (fix)\r\n\r\n# L016 - Lines should be 120 characters of less. Comment lines should not be ignored (fix)\r\n[sqlfluff:rules:L016]\r\nignore_comment_lines = False\r\nmax_line_length = 120\r\n\r\n# L017 - There should not be whitespace between function name and brackets (fix)\r\n# L018 - Always align closing bracket of WITH to the WITH keyword (fix)\r\n\r\n# L019 - Always use trailing commas / commas at the end of the line (fix)\r\n[sqlfluff:rules:L019]\r\ncomma_style = trailing\r\n\r\n# L020 - Table aliases will always be unique per statement\r\n# L021 - Remove any use of ambiguous DISTINCT and GROUP BY combinations. Lean on removing the GROUP BY.\r\n# L022 - Add blank lines after common table expressions (CTE) / WITH.\r\n# L023 - Always add a single whitespace after AS in a WITH clause (fix)\r\n\r\n[sqlfluff:rules:L026]\r\nforce_enable = False\r\n\r\n# L027 - Always add references if more than one referenced table or view is used\r\n\r\n[sqlfluff:rules:L028]\r\nforce_enable = False\r\n\r\n[sqlfluff:rules:L029]  # Keyword identifiers\r\nunquoted_identifiers_policy = aliases\r\n\r\n[sqlfluff:rules:L030]  # Function names\r\ncapitalisation_policy = upper\r\n\r\n# L032 - We prefer use of join keys rather than USING\r\n# L034 - We prefer ordering of columns in select statements as (fix):\r\n# 1. wildcards\r\n# 2. single identifiers\r\n# 3. calculations and aggregates\r\n\r\n# L035 - Omit \'else NULL\'; it is redundant (fix)\r\n# L036 - Move select targets / identifiers onto new lines each (fix)\r\n# L037 - When using ORDER BY, make the direction explicit (fix)\r\n\r\n# L038 - Never use trailing commas at the end of the SELECT clause\r\n[sqlfluff:rules:L038]\r\nselect_clause_trailing_comma = forbid\r\n\r\n# L039 - Remove unnecessary whitespace (fix)\r\n\r\n[sqlfluff:rules:L040]  # Null & Boolean Literals\r\ncapitalisation_policy = upper\r\n\r\n# L042 - Join clauses should not contain subqueries. Use common tables expressions (CTE) instead.\r\n[sqlfluff:rules:L042]\r\n# By default, allow subqueries in from clauses, but not join clauses.\r\nforbid_subquery_in = join\r\n\r\n# L043 - Reduce CASE WHEN conditions to COALESCE (fix)\r\n# L044 - Prefer a known number of columns along the path to the source data\r\n# L045 - Remove unused common tables expressions (CTE) / WITH statements (fix)\r\n# L046 - Jinja tags should have a single whitespace on both sides\r\n\r\n# L047 - Use COUNT(*) instead of COUNT(0) or COUNT(1) alternatives (fix)\r\n[sqlfluff:rules:L047]  # Consistent syntax to count all rows\r\nprefer_count_1 = False\r\nprefer_count_0 = False\r\n\r\n# L048 - Quoted literals should be surrounded by a single whitespace (fix)\r\n# L049 - Always use IS or IS NOT for comparisons with NULL (fix)\r\n```\r\n\n\n\nINSTRUCTIONS:\nNow, you\'re going to solve this issue on your own. Your terminal session has started and you\'re in the repository\'s root directory. You can use any bash commands or the special interface to help you. Edit all the files you need to and run any checks or tests that you want.\nRemember, YOU CAN ONLY ENTER ONE COMMAND AT A TIME. You should always wait for feedback after every command.\nWhen you\'re satisfied with all of the changes you\'ve made, you can submit your changes to the code base by simply running the submit command.\nNote however that you cannot use any interactive session commands (e.g. python, vim) in this environment, but you can write scripts and run them. E.g. you can write a python script and then run it with `python <script_name>.py`.\n\nNOTE ABOUT THE EDIT COMMAND: Indentation really matters! When editing a file, make sure to insert appropriate indentation before each line!\n\nIMPORTANT TIPS:\n1. Always start by trying to replicate the bug that the issues discusses.\n   If the issue includes code for reproducing the bug, we recommend that you re-implement that in your environment, and run it to make sure you can reproduce the bug.\n   Then start trying to fix it.\n   When you think you\'ve fixed the bug, re-run the bug reproduction script to make sure that the bug has indeed been fixed.\n\n   If the bug reproduction script does not print anything when it successfully runs, we recommend adding a print("Script completed successfully, no errors.") command at the end of the file,\n   so that you can be sure that the script indeed ran fine all the way through.\n\n2. If you run a command and it doesn\'t work, try running a different command. A command that did not work once will not work the second time unless you modify it!\n\n3. If you open a file and need to get to an area around a specific line that is not in the first 100 lines, say line 583, don\'t just use the scroll_down command multiple times. Instead, use the goto 583 command. It\'s much quicker.\n\n4. If the bug reproduction script requires inputting/reading a specific file, such as buggy-input.png, and you\'d like to understand how to input that file, conduct a search in the existing repo code, to see whether someone else has already done that. Do this by running the command: find_file "buggy-input.png" If that doesn\'t work, use the linux \'find\' command.\n\n5. Always make sure to look at the currently open file and the current working directory (which appears right after the currently open file). The currently open file might be in a different directory than the working directory! Note that some commands, such as \'create\', open files, so they might change the current  open file.\n\n6. When editing files, it is easy to accidentally specify a wrong line number or to write code with incorrect indentation. Always check the code after you issue an edit to make sure that it reflects what you wanted to accomplish. If it didn\'t, issue another command to fix it.\n\n\n(Open file: n/a)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': "To start addressing the issue, we need to reproduce the error first. The issue provides a SQL file and the command to run. Let's create a new file called `reproduce.sql` and paste the provided SQL code into it.\n\n```\ncreate reproduce.sql\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': '[File: /sqlfluff__sqlfluff/reproduce.sql (1 lines total)]\n1:\n(Open file: /sqlfluff__sqlfluff/reproduce.sql)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': "Now let's paste the provided SQL code into the `reproduce.sql` file.\n\n```\nedit 1:1\nSELECT\n    reacted_table_name_right.descendant_id AS category_id,\n    string_agg(redacted_table_name_left.name, ' â†’ ' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\nFROM {{ ref2('redacted_schema_name', 'redacted_table_name_left') }} AS redacted_table_name_left\nINNER JOIN {{ ref2('redacted_schema_name', 'reacted_table_name_right') }} AS reacted_table_name_right\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\nGROUP BY reacted_table_name_right.descendant_id\nend_of_edit\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': "[File: /sqlfluff__sqlfluff/reproduce.sql (7 lines total)]\n1:SELECT\n2:    reacted_table_name_right.descendant_id AS category_id,\n3:    string_agg(redacted_table_name_left.name, ' â†’ ' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\n4:FROM {{ ref2('redacted_schema_name', 'redacted_table_name_left') }} AS redacted_table_name_left\n5:INNER JOIN {{ ref2('redacted_schema_name', 'reacted_table_name_right') }} AS reacted_table_name_right\n6:    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\n7:GROUP BY reacted_table_name_right.descendant_id\nFile updated. Please review the changes and make sure they are correct (correct indentation, no duplicate lines, etc). Edit the file again if necessary.\n(Open file: /sqlfluff__sqlfluff/reproduce.sql)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$"}, {'role': 'assistant', 'content': "The SQL code has been successfully added to the `reproduce.sql` file. Now, let's run the `sqlfluff fix` command with the provided options to reproduce the error.\n\n```\nsqlfluff fix reproduce.sql --ignore templating,parsing,lexing -vvvv\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': '==== sqlfluff ====\nsqlfluff:                0.7.1 python:                 3.9.19\nimplementation:        cpython dialect:                  ansi\nverbosity:                   4 templater:               jinja\n\n== Raw Config:\ncore:                                   \n    dialect:            ansi                \n    encoding:           autodetect          \n    ignore:             [\'templating\', \'parsing\', \'lexing\']\n    ignore_templated_areas:True                \n    nocolor:            False               \n    output_line_length: 80                  \n    recurse:            True                \n    runaway_limit:      10                  \n    sql_file_exts:      .sql,.sql.j2,.dml,.ddl\n    templater:          jinja               \n    verbose:            4                   \nindentation:                            \n    indented_joins:     False               \n    indented_using_on:  True                \n    template_blocks_indent:True                \nrules:                                  \n    allow_scalar:       True                \n    comma_style:        trailing            \n    indent_unit:        space               \n    max_line_length:    80                  \n    single_table_references:consistent          \n    tab_space_size:     4                   \n    unquoted_identifiers_policy:all                 \n    L007:                                   \n        operator_new_lines: after               \n    L010:                                   \n        capitalisation_policy:consistent          \n    L011:                                   \n        aliasing:           explicit            \n    L012:                                   \n        aliasing:           explicit            \n    L014:                                   \n        extended_capitalisation_policy:consistent          \n    L016:                                   \n        ignore_comment_lines:False               \n    L026:                                   \n        force_enable:       False               \n    L028:                                   \n        force_enable:       False               \n    L029:                                   \n        unquoted_identifiers_policy:aliases             \n    L030:                                   \n        capitalisation_policy:consistent          \n    L038:                                   \n        select_clause_trailing_comma:forbid              \n    L040:                                   \n        capitalisation_policy:consistent          \n    L042:                                   \n        forbid_subquery_in: join                \n    L047:                                   \n        prefer_count_0:     False               \n        prefer_count_1:     False               \ntemplater:                              \n    unwrap_wrapped_queries:True                \n    jinja:                                  \n        apply_dbt_builtins: True                \n        macros:                                 \n            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}\n            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}\n            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}\n            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}\n            dbt_var:            {% macro var(variable, default=\'\') %}item{% endmacro %}\n\n==== finding fixable violations ====\n=== [ path: reproduce.sql ] ===\n\nINFO       TEMPLATING RAW [jinja] (reproduce.sql)\nINFO       Unrecoverable Jinja Error: \'ref2\' is undefined\nINFO       TEMPLATING FAILED: [SQLTemplaterError("Undefined jinja template variable: \'ref2\'"), SQLTemplaterError("Undefined jinja template variable: \'ref2\'"), SQLTemplaterError("Unrecoverable failure in Jinja templating: \'ref2\' is undefined. Have you configured your variables? https://docs.sqlfluff.com/en/latest/configuration.html")]\nINFO       [L001] No config_keywords defined for L001\nINFO       [L005] No config_keywords defined for L005\nINFO       [L006] No config_keywords defined for L006\nINFO       [L008] No config_keywords defined for L008\nINFO       [L009] No config_keywords defined for L009\nINFO       [L015] No config_keywords defined for L015\nINFO       [L017] No config_keywords defined for L017\nINFO       [L020] No config_keywords defined for L020\nINFO       [L021] No config_keywords defined for L021\nINFO       [L023] No config_keywords defined for L023\nINFO       [L024] No config_keywords defined for L024\nINFO       [L025] No config_keywords defined for L025\nINFO       [L027] No config_keywords defined for L027\nINFO       [L031] No config_keywords defined for L031\nINFO       [L032] No config_keywords defined for L032\nINFO       [L033] No config_keywords defined for L033\nINFO       [L034] No config_keywords defined for L034\nINFO       [L035] No config_keywords defined for L035\nINFO       [L036] No config_keywords defined for L036\nINFO       [L037] No config_keywords defined for L037\nINFO       [L039] No config_keywords defined for L039\nINFO       [L041] No config_keywords defined for L041\nINFO       [L043] No config_keywords defined for L043\nINFO       [L044] No config_keywords defined for L044\nINFO       [L045] No config_keywords defined for L045\nINFO       [L046] No config_keywords defined for L046\nINFO       [L048] No config_keywords defined for L048\nINFO       [L049] No config_keywords defined for L049\nINFO       PARSING (reproduce.sql)\n== [reproduce.sql] PASS\n==== no fixable linting violations found ====\nAll Finished ðŸ“œ ðŸŽ‰!\n(Open file: /sqlfluff__sqlfluff/reproduce.sql)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': "The `sqlfluff fix` command failed due to an undefined Jinja template variable `ref2`. This is expected since the `ref2` macro is not defined in the provided configuration.\n\nTo proceed, we need to define the `ref2` macro in the configuration. Let's create a new configuration file `sqlfluff_config.ini` and add the necessary macro definitions.\n\n```\ncreate sqlfluff_config.ini\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': '[File: /sqlfluff__sqlfluff/sqlfluff_config.ini (1 lines total)]\n1:\n(Open file: /sqlfluff__sqlfluff/sqlfluff_config.ini)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': "Now let's add the necessary macro definitions to the `sqlfluff_config.ini` file.\n\n```\nedit 1:1\n[sqlfluff:templater:jinja:macros]\nref2 = {% macro ref2(schema, table) %}{{ schema }}_{{ table }}{% endmacro %}\nend_of_edit\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': '[File: /sqlfluff__sqlfluff/sqlfluff_config.ini (2 lines total)]\n1:[sqlfluff:templater:jinja:macros]\n2:ref2 = {% macro ref2(schema, table) %}{{ schema }}_{{ table }}{% endmacro %}\nFile updated. Please review the changes and make sure they are correct (correct indentation, no duplicate lines, etc). Edit the file again if necessary.\n(Open file: /sqlfluff__sqlfluff/sqlfluff_config.ini)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': "The macro definition for `ref2` has been added to the `sqlfluff_config.ini` file. Now, let's run the `sqlfluff fix` command again, but this time we will specify the configuration file to ensure it uses our new macro definition.\n\n```\nsqlfluff fix reproduce.sql --ignore templating,parsing,lexing -vvvv --config sqlfluff_config.ini\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': "Usage: sqlfluff fix [OPTIONS] [PATHS]...\nTry 'sqlfluff fix --help' for help.\n\nError: No such option: --config\n(Open file: /sqlfluff__sqlfluff/sqlfluff_config.ini)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$"}, {'role': 'assistant', 'content': "It seems that `sqlfluff` does not support specifying a configuration file directly via a command-line option. Instead, we should place the configuration file in the appropriate location where `sqlfluff` will automatically detect it.\n\nLet's move the `sqlfluff_config.ini` file to the `.sqlfluff` directory, which is the default location for `sqlfluff` configuration files.\n\n```\nmv sqlfluff_config.ini .sqlfluff\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': 'Your command ran successfully and did not produce any output.\n(Open file: /sqlfluff__sqlfluff/sqlfluff_config.ini)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': "The configuration file has been moved to the `.sqlfluff` directory. Now, let's run the `sqlfluff fix` command again to see if it can process the SQL file correctly with the new macro definition.\n\n```\nsqlfluff fix reproduce.sql --ignore templating,parsing,lexing -vvvv\n```"}]}
{'messages': [{'role': 'system', 'content': 'You are a seasoned engineer who takes bug descriptions \n                    and generates a patch to fix the bug. '}, {'role': 'user', 'content': '==== sqlfluff ====\nsqlfluff:                0.7.1 python:                 3.9.19\nimplementation:        cpython dialect:                  ansi\nverbosity:                   4 templater:               jinja\n\n== Raw Config:\ncore:                                   \n    dialect:            ansi                \n    encoding:           autodetect          \n    ignore:             [\'templating\', \'parsing\', \'lexing\']\n    ignore_templated_areas:True                \n    nocolor:            False               \n    output_line_length: 80                  \n    recurse:            True                \n    runaway_limit:      10                  \n    sql_file_exts:      .sql,.sql.j2,.dml,.ddl\n    templater:          jinja               \n    verbose:            4                   \nindentation:                            \n    indented_joins:     False               \n    indented_using_on:  True                \n    template_blocks_indent:True                \nrules:                                  \n    allow_scalar:       True                \n    comma_style:        trailing            \n    indent_unit:        space               \n    max_line_length:    80                  \n    single_table_references:consistent          \n    tab_space_size:     4                   \n    unquoted_identifiers_policy:all                 \n    L007:                                   \n        operator_new_lines: after               \n    L010:                                   \n        capitalisation_policy:consistent          \n    L011:                                   \n        aliasing:           explicit            \n    L012:                                   \n        aliasing:           explicit            \n    L014:                                   \n        extended_capitalisation_policy:consistent          \n    L016:                                   \n        ignore_comment_lines:False               \n    L026:                                   \n        force_enable:       False               \n    L028:                                   \n        force_enable:       False               \n    L029:                                   \n        unquoted_identifiers_policy:aliases             \n    L030:                                   \n        capitalisation_policy:consistent          \n    L038:                                   \n        select_clause_trailing_comma:forbid              \n    L040:                                   \n        capitalisation_policy:consistent          \n    L042:                                   \n        forbid_subquery_in: join                \n    L047:                                   \n        prefer_count_0:     False               \n        prefer_count_1:     False               \ntemplater:                              \n    unwrap_wrapped_queries:True                \n    jinja:                                  \n        apply_dbt_builtins: True                \n        macros:                                 \n            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}\n            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}\n            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}\n            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}\n            dbt_var:            {% macro var(variable, default=\'\') %}item{% endmacro %}\n            ref2:               {% macro ref2(schema, table) %}{{ schema }}_{{ table }}{% endmacro %}\n\n==== finding fixable violations ====\n=== [ path: reproduce.sql ] ===\n\nINFO       TEMPLATING RAW [jinja] (reproduce.sql)\nINFO       Slicing File Template\nDEBUG          Raw String: "SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM {{ ref2(\'redacted_schema_name\', \'redacted_table_name_left\') }} AS redacted_table_name_left\\nINNER JOIN {{ ref2(\'redacted_schema_name\', \'reacted_table_name_right\') }} AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n"\nDEBUG          Templated String: "SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM redacted_schema_name_redacted_table_name_left AS redacted_table_name_left\\nINNER JOIN redacted_schema_name_reacted_table_name_right AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n"\nDEBUG          Raw Sliced:\nDEBUG              0: RawFileSlice(raw="SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM ", slice_type=\'literal\', source_idx=0, slice_subtype=None)\nDEBUG              1: RawFileSlice(raw="{{ ref2(\'redacted_schema_name\', \'redacted_table_name_left\') }}", slice_type=\'templated\', source_idx=200, slice_subtype=None)\nDEBUG              2: RawFileSlice(raw=\' AS redacted_table_name_left\\nINNER JOIN \', slice_type=\'literal\', source_idx=262, slice_subtype=None)\nDEBUG              3: RawFileSlice(raw="{{ ref2(\'redacted_schema_name\', \'reacted_table_name_right\') }}", slice_type=\'templated\', source_idx=302, slice_subtype=None)\nDEBUG              4: RawFileSlice(raw=\' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\', slice_type=\'literal\', source_idx=364, slice_subtype=None)\nDEBUG          Literals: ["SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM ", \' AS redacted_table_name_left\\nINNER JOIN \', \' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\']\nDEBUG          # Slice Loop 0\nDEBUG          Occurrences: Raw: {"SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM ": [0], \' AS redacted_table_name_left\\nINNER JOIN \': [262], \' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\': [364]}, Templated: {"SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM ": [0], \' AS redacted_table_name_left\\nINNER JOIN \': [245], \' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\': [330]}\nDEBUG          Split Sliced:\nDEBUG              0: IntermediateFileSlice(intermediate_type=\'invariant\', source_slice=slice(0, 200, None), templated_slice=slice(0, 200, None), slice_buffer=[RawFileSlice(raw="SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM ", slice_type=\'literal\', source_idx=0, slice_subtype=None)])\nDEBUG              1: IntermediateFileSlice(intermediate_type=\'compound\', source_slice=slice(200, 262, None), templated_slice=slice(200, 245, None), slice_buffer=[RawFileSlice(raw="{{ ref2(\'redacted_schema_name\', \'redacted_table_name_left\') }}", slice_type=\'templated\', source_idx=200, slice_subtype=None)])\nDEBUG              2: IntermediateFileSlice(intermediate_type=\'invariant\', source_slice=slice(262, 302, None), templated_slice=slice(245, 285, None), slice_buffer=[RawFileSlice(raw=\' AS redacted_table_name_left\\nINNER JOIN \', slice_type=\'literal\', source_idx=245, slice_subtype=None)])\nDEBUG              3: IntermediateFileSlice(intermediate_type=\'compound\', source_slice=slice(302, 364, None), templated_slice=slice(285, 330, None), slice_buffer=[RawFileSlice(raw="{{ ref2(\'redacted_schema_name\', \'reacted_table_name_right\') }}", slice_type=\'templated\', source_idx=302, slice_subtype=None)])\nDEBUG              4: IntermediateFileSlice(intermediate_type=\'invariant\', source_slice=slice(364, 523, None), templated_slice=slice(330, 489, None), slice_buffer=[RawFileSlice(raw=\' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\', slice_type=\'literal\', source_idx=330, slice_subtype=None)])\nDEBUG          _split_uniques_coalesce_rest: [IntermediateFileSlice(intermediate_type=\'invariant\', source_slice=slice(0, 200, None), templated_slice=slice(0, 200, None), slice_buffer=[RawFileSlice(raw="SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM ", slice_type=\'literal\', source_idx=0, slice_subtype=None)]), IntermediateFileSlice(intermediate_type=\'compound\', source_slice=slice(200, 262, None), templated_slice=slice(200, 245, None), slice_buffer=[RawFileSlice(raw="{{ ref2(\'redacted_schema_name\', \'redacted_table_name_left\') }}", slice_type=\'templated\', source_idx=200, slice_subtype=None)]), IntermediateFileSlice(intermediate_type=\'invariant\', source_slice=slice(262, 302, None), templated_slice=slice(245, 285, None), slice_buffer=[RawFileSlice(raw=\' AS redacted_table_name_left\\nINNER JOIN \', slice_type=\'literal\', source_idx=245, slice_subtype=None)]), IntermediateFileSlice(intermediate_type=\'compound\', source_slice=slice(302, 364, None), templated_slice=slice(285, 330, None), slice_buffer=[RawFileSlice(raw="{{ ref2(\'redacted_schema_name\', \'reacted_table_name_right\') }}", slice_type=\'templated\', source_idx=302, slice_subtype=None)]), IntermediateFileSlice(intermediate_type=\'invariant\', source_slice=slice(364, 523, None), templated_slice=slice(330, 489, None), slice_buffer=[RawFileSlice(raw=\' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\', slice_type=\'literal\', source_idx=330, slice_subtype=None)])]\nDEBUG              Yielding Simple: TemplatedFileSlice(slice_type=\'literal\', source_slice=slice(0, 200, None), templated_slice=slice(0, 200, None))\nDEBUG              Yielding Simple: TemplatedFileSlice(slice_type=\'templated\', source_slice=slice(200, 262, None), templated_slice=slice(200, 245, None))\nDEBUG              Yielding Simple: TemplatedFileSlice(slice_type=\'literal\', source_slice=slice(262, 302, None), templated_slice=slice(245, 285, None))\nDEBUG              Yielding Simple: TemplatedFileSlice(slice_type=\'templated\', source_slice=slice(302, 364, None), templated_slice=slice(285, 330, None))\nDEBUG              Yielding Simple: TemplatedFileSlice(slice_type=\'literal\', source_slice=slice(364, 523, None), templated_slice=slice(330, 489, None))\nDEBUG          Fully Sliced:\nDEBUG              0: TemplatedFileSlice(slice_type=\'literal\', source_slice=slice(0, 200, None), templated_slice=slice(0, 200, None))\nDEBUG              1: TemplatedFileSlice(slice_type=\'templated\', source_slice=slice(200, 262, None), templated_slice=slice(200, 245, None))\nDEBUG              2: TemplatedFileSlice(slice_type=\'literal\', source_slice=slice(262, 302, None), templated_slice=slice(245, 285, None))\nDEBUG              3: TemplatedFileSlice(slice_type=\'templated\', source_slice=slice(302, 364, None), templated_slice=slice(285, 330, None))\nDEBUG              4: TemplatedFileSlice(slice_type=\'literal\', source_slice=slice(364, 523, None), templated_slice=slice(330, 489, None))\nINFO       [L001] No config_keywords defined for L001\nINFO       [L005] No config_keywords defined for L005\nINFO       [L006] No config_keywords defined for L006\nINFO       [L008] No config_keywords defined for L008\nINFO       [L009] No config_keywords defined for L009\nINFO       [L015] No config_keywords defined for L015\nINFO       [L017] No config_keywords defined for L017\nINFO       [L020] No config_keywords defined for L020\nINFO       [L021] No config_keywords defined for L021\nINFO       [L023] No config_keywords defined for L023\nINFO       [L024] No config_keywords defined for L024\nINFO       [L025] No config_keywords defined for L025\nINFO       [L027] No config_keywords defined for L027\nINFO       [L031] No config_keywords defined for L031\nINFO       [L032] No config_keywords defined for L032\nINFO       [L033] No config_keywords defined for L033\nINFO       [L034] No config_keywords defined for L034\nINFO       [L035] No config_keywords defined for L035\nINFO       [L036] No config_keywords defined for L036\nINFO       [L037] No config_keywords defined for L037\nINFO       [L039] No config_keywords defined for L039\nINFO       [L041] No config_keywords defined for L041\nINFO       [L043] No config_keywords defined for L043\nINFO       [L044] No config_keywords defined for L044\nINFO       [L045] No config_keywords defined for L045\nINFO       [L046] No config_keywords defined for L046\nINFO       [L048] No config_keywords defined for L048\nINFO       [L049] No config_keywords defined for L049\nINFO       LEXING RAW (reproduce.sql)\nINFO       Elements to Segments.\nINFO       Source-only slices: []\nDEBUG        0, TemplateElement(raw=\'SELECT\', template_slice=slice(0, 6, None), matcher=<RegexLexer: code>), slice(0, 6, None), \'SELECT\'\nDEBUG        1, TemplateElement(raw=\'\\n\', template_slice=slice(6, 7, None), matcher=<RegexLexer: newline>), slice(6, 7, None), \'\\n\'\nDEBUG        2, TemplateElement(raw=\'    \', template_slice=slice(7, 11, None), matcher=<RegexLexer: whitespace>), slice(7, 11, None), \'    \'\nDEBUG        3, TemplateElement(raw=\'reacted_table_name_right\', template_slice=slice(11, 35, None), matcher=<RegexLexer: code>), slice(11, 35, None), \'reacted_table_name_right\'\nDEBUG        4, TemplateElement(raw=\'.\', template_slice=slice(35, 36, None), matcher=<StringLexer: dot>), slice(35, 36, None), \'.\'\nDEBUG        5, TemplateElement(raw=\'descendant_id\', template_slice=slice(36, 49, None), matcher=<RegexLexer: code>), slice(36, 49, None), \'descendant_id\'\nDEBUG        6, TemplateElement(raw=\' \', template_slice=slice(49, 50, None), matcher=<RegexLexer: whitespace>), slice(49, 50, None), \' \'\nDEBUG        7, TemplateElement(raw=\'AS\', template_slice=slice(50, 52, None), matcher=<RegexLexer: code>), slice(50, 52, None), \'AS\'\nDEBUG        8, TemplateElement(raw=\' \', template_slice=slice(52, 53, None), matcher=<RegexLexer: whitespace>), slice(52, 53, None), \' \'\nDEBUG        9, TemplateElement(raw=\'category_id\', template_slice=slice(53, 64, None), matcher=<RegexLexer: code>), slice(53, 64, None), \'category_id\'\nDEBUG        10, TemplateElement(raw=\',\', template_slice=slice(64, 65, None), matcher=<StringLexer: comma>), slice(64, 65, None), \',\'\nDEBUG        11, TemplateElement(raw=\'\\n\', template_slice=slice(65, 66, None), matcher=<RegexLexer: newline>), slice(65, 66, None), \'\\n\'\nDEBUG        12, TemplateElement(raw=\'    \', template_slice=slice(66, 70, None), matcher=<RegexLexer: whitespace>), slice(66, 70, None), \'    \'\nDEBUG        13, TemplateElement(raw=\'string_agg\', template_slice=slice(70, 80, None), matcher=<RegexLexer: code>), slice(70, 80, None), \'string_agg\'\nDEBUG        14, TemplateElement(raw=\'(\', template_slice=slice(80, 81, None), matcher=<StringLexer: bracket_open>), slice(80, 81, None), \'(\'\nDEBUG        15, TemplateElement(raw=\'redacted_table_name_left\', template_slice=slice(81, 105, None), matcher=<RegexLexer: code>), slice(81, 105, None), \'redacted_table_name_left\'\nDEBUG        16, TemplateElement(raw=\'.\', template_slice=slice(105, 106, None), matcher=<StringLexer: dot>), slice(105, 106, None), \'.\'\nDEBUG        17, TemplateElement(raw=\'name\', template_slice=slice(106, 110, None), matcher=<RegexLexer: code>), slice(106, 110, None), \'name\'\nDEBUG        18, TemplateElement(raw=\',\', template_slice=slice(110, 111, None), matcher=<StringLexer: comma>), slice(110, 111, None), \',\'\nDEBUG        19, TemplateElement(raw=\' \', template_slice=slice(111, 112, None), matcher=<RegexLexer: whitespace>), slice(111, 112, None), \' \'\nDEBUG        20, TemplateElement(raw="\' Ã¢â€ â€™ \'", template_slice=slice(112, 119, None), matcher=<RegexLexer: single_quote>), slice(112, 119, None), "\' Ã¢â€ â€™ \'"\nDEBUG        21, TemplateElement(raw=\' \', template_slice=slice(119, 120, None), matcher=<RegexLexer: whitespace>), slice(119, 120, None), \' \'\nDEBUG        22, TemplateElement(raw=\'ORDER\', template_slice=slice(120, 125, None), matcher=<RegexLexer: code>), slice(120, 125, None), \'ORDER\'\nDEBUG        23, TemplateElement(raw=\' \', template_slice=slice(125, 126, None), matcher=<RegexLexer: whitespace>), slice(125, 126, None), \' \'\nDEBUG        24, TemplateElement(raw=\'BY\', template_slice=slice(126, 128, None), matcher=<RegexLexer: code>), slice(126, 128, None), \'BY\'\nDEBUG        25, TemplateElement(raw=\' \', template_slice=slice(128, 129, None), matcher=<RegexLexer: whitespace>), slice(128, 129, None), \' \'\nDEBUG        26, TemplateElement(raw=\'reacted_table_name_right\', template_slice=slice(129, 153, None), matcher=<RegexLexer: code>), slice(129, 153, None), \'reacted_table_name_right\'\nDEBUG        27, TemplateElement(raw=\'.\', template_slice=slice(153, 154, None), matcher=<StringLexer: dot>), slice(153, 154, None), \'.\'\nDEBUG        28, TemplateElement(raw=\'generations\', template_slice=slice(154, 165, None), matcher=<RegexLexer: code>), slice(154, 165, None), \'generations\'\nDEBUG        29, TemplateElement(raw=\' \', template_slice=slice(165, 166, None), matcher=<RegexLexer: whitespace>), slice(165, 166, None), \' \'\nDEBUG        30, TemplateElement(raw=\'DESC\', template_slice=slice(166, 170, None), matcher=<RegexLexer: code>), slice(166, 170, None), \'DESC\'\nDEBUG        31, TemplateElement(raw=\')\', template_slice=slice(170, 171, None), matcher=<StringLexer: bracket_close>), slice(170, 171, None), \')\'\nDEBUG        32, TemplateElement(raw=\' \', template_slice=slice(171, 172, None), matcher=<RegexLexer: whitespace>), slice(171, 172, None), \' \'\nDEBUG        33, TemplateElement(raw=\'AS\', template_slice=slice(172, 174, None), matcher=<RegexLexer: code>), slice(172, 174, None), \'AS\'\nDEBUG        34, TemplateElement(raw=\' \', template_slice=slice(174, 175, None), matcher=<RegexLexer: whitespace>), slice(174, 175, None), \' \'\nDEBUG        35, TemplateElement(raw=\'breadcrumbs\', template_slice=slice(175, 186, None), matcher=<RegexLexer: code>), slice(175, 186, None), \'breadcrumbs\'\nDEBUG        36, TemplateElement(raw=\' \', template_slice=slice(186, 187, None), matcher=<RegexLexer: whitespace>), slice(186, 187, None), \' \'\nDEBUG        37, TemplateElement(raw=\'-- noqa\', template_slice=slice(187, 194, None), matcher=<RegexLexer: inline_comment>), slice(187, 194, None), \'-- noqa\'\nDEBUG        38, TemplateElement(raw=\'\\n\', template_slice=slice(194, 195, None), matcher=<RegexLexer: newline>), slice(194, 195, None), \'\\n\'\nDEBUG        39, TemplateElement(raw=\'FROM\', template_slice=slice(195, 199, None), matcher=<RegexLexer: code>), slice(195, 199, None), \'FROM\'\nDEBUG        40, TemplateElement(raw=\' \', template_slice=slice(199, 200, None), matcher=<RegexLexer: whitespace>), slice(199, 200, None), \' \'\nDEBUG        41, TemplateElement(raw=\'redacted_schema_name_redacted_table_name_left\', template_slice=slice(200, 245, None), matcher=<RegexLexer: code>), slice(200, 262, None), \'redacted_schema_name_redacted_table_name_left\'\nDEBUG        42, TemplateElement(raw=\' \', template_slice=slice(245, 246, None), matcher=<RegexLexer: whitespace>), slice(262, 263, None), \' \'\nDEBUG        43, TemplateElement(raw=\'AS\', template_slice=slice(246, 248, None), matcher=<RegexLexer: code>), slice(263, 265, None), \'AS\'\nDEBUG        44, TemplateElement(raw=\' \', template_slice=slice(248, 249, None), matcher=<RegexLexer: whitespace>), slice(265, 266, None), \' \'\nDEBUG        45, TemplateElement(raw=\'redacted_table_name_left\', template_slice=slice(249, 273, None), matcher=<RegexLexer: code>), slice(266, 290, None), \'redacted_table_name_left\'\nDEBUG        46, TemplateElement(raw=\'\\n\', template_slice=slice(273, 274, None), matcher=<RegexLexer: newline>), slice(290, 291, None), \'\\n\'\nDEBUG        47, TemplateElement(raw=\'INNER\', template_slice=slice(274, 279, None), matcher=<RegexLexer: code>), slice(291, 296, None), \'INNER\'\nDEBUG        48, TemplateElement(raw=\' \', template_slice=slice(279, 280, None), matcher=<RegexLexer: whitespace>), slice(296, 297, None), \' \'\nDEBUG        49, TemplateElement(raw=\'JOIN\', template_slice=slice(280, 284, None), matcher=<RegexLexer: code>), slice(297, 301, None), \'JOIN\'\nDEBUG        50, TemplateElement(raw=\' \', template_slice=slice(284, 285, None), matcher=<RegexLexer: whitespace>), slice(301, 302, None), \' \'\nDEBUG        51, TemplateElement(raw=\'redacted_schema_name_reacted_table_name_right\', template_slice=slice(285, 330, None), matcher=<RegexLexer: code>), slice(302, 364, None), \'redacted_schema_name_reacted_table_name_right\'\nDEBUG        52, TemplateElement(raw=\' \', template_slice=slice(330, 331, None), matcher=<RegexLexer: whitespace>), slice(364, 365, None), \' \'\nDEBUG        53, TemplateElement(raw=\'AS\', template_slice=slice(331, 333, None), matcher=<RegexLexer: code>), slice(365, 367, None), \'AS\'\nDEBUG        54, TemplateElement(raw=\' \', template_slice=slice(333, 334, None), matcher=<RegexLexer: whitespace>), slice(367, 368, None), \' \'\nDEBUG        55, TemplateElement(raw=\'reacted_table_name_right\', template_slice=slice(334, 358, None), matcher=<RegexLexer: code>), slice(368, 392, None), \'reacted_table_name_right\'\nDEBUG        56, TemplateElement(raw=\'\\n\', template_slice=slice(358, 359, None), matcher=<RegexLexer: newline>), slice(392, 393, None), \'\\n\'\nDEBUG        57, TemplateElement(raw=\'    \', template_slice=slice(359, 363, None), matcher=<RegexLexer: whitespace>), slice(393, 397, None), \'    \'\nDEBUG        58, TemplateElement(raw=\'ON\', template_slice=slice(363, 365, None), matcher=<RegexLexer: code>), slice(397, 399, None), \'ON\'\nDEBUG        59, TemplateElement(raw=\' \', template_slice=slice(365, 366, None), matcher=<RegexLexer: whitespace>), slice(399, 400, None), \' \'\nDEBUG        60, TemplateElement(raw=\'redacted_table_name_left\', template_slice=slice(366, 390, None), matcher=<RegexLexer: code>), slice(400, 424, None), \'redacted_table_name_left\'\nDEBUG        61, TemplateElement(raw=\'.\', template_slice=slice(390, 391, None), matcher=<StringLexer: dot>), slice(424, 425, None), \'.\'\nDEBUG        62, TemplateElement(raw=\'id\', template_slice=slice(391, 393, None), matcher=<RegexLexer: code>), slice(425, 427, None), \'id\'\nDEBUG        63, TemplateElement(raw=\' \', template_slice=slice(393, 394, None), matcher=<RegexLexer: whitespace>), slice(427, 428, None), \' \'\nDEBUG        64, TemplateElement(raw=\'=\', template_slice=slice(394, 395, None), matcher=<StringLexer: equals>), slice(428, 429, None), \'=\'\nDEBUG        65, TemplateElement(raw=\' \', template_slice=slice(395, 396, None), matcher=<RegexLexer: whitespace>), slice(429, 430, None), \' \'\nDEBUG        66, TemplateElement(raw=\'order_issue_category_hierarchies\', template_slice=slice(396, 428, None), matcher=<RegexLexer: code>), slice(430, 462, None), \'order_issue_category_hierarchies\'\nDEBUG        67, TemplateElement(raw=\'.\', template_slice=slice(428, 429, None), matcher=<StringLexer: dot>), slice(462, 463, None), \'.\'\nDEBUG        68, TemplateElement(raw=\'ancestor_id\', template_slice=slice(429, 440, None), matcher=<RegexLexer: code>), slice(463, 474, None), \'ancestor_id\'\nDEBUG        69, TemplateElement(raw=\'\\n\', template_slice=slice(440, 441, None), matcher=<RegexLexer: newline>), slice(474, 475, None), \'\\n\'\nDEBUG        70, TemplateElement(raw=\'GROUP\', template_slice=slice(441, 446, None), matcher=<RegexLexer: code>), slice(475, 480, None), \'GROUP\'\nDEBUG        71, TemplateElement(raw=\' \', template_slice=slice(446, 447, None), matcher=<RegexLexer: whitespace>), slice(480, 481, None), \' \'\nDEBUG        72, TemplateElement(raw=\'BY\', template_slice=slice(447, 449, None), matcher=<RegexLexer: code>), slice(481, 483, None), \'BY\'\nDEBUG        73, TemplateElement(raw=\' \', template_slice=slice(449, 450, None), matcher=<RegexLexer: whitespace>), slice(483, 484, None), \' \'\nDEBUG        74, TemplateElement(raw=\'reacted_table_name_right\', template_slice=slice(450, 474, None), matcher=<RegexLexer: code>), slice(484, 508, None), \'reacted_table_name_right\'\nDEBUG        75, TemplateElement(raw=\'.\', template_slice=slice(474, 475, None), matcher=<StringLexer: dot>), slice(508, 509, None), \'.\'\nDEBUG        76, TemplateElement(raw=\'descendant_id\', template_slice=slice(475, 488, None), matcher=<RegexLexer: code>), slice(509, 522, None), \'descendant_id\'\nDEBUG        77, TemplateElement(raw=\'\\n\', template_slice=slice(488, 489, None), matcher=<RegexLexer: newline>), slice(522, 523, None), \'\\n\'\nINFO       Lexed tokens: [\'SELECT\', \'\\n\', \'    \', \'reacted_table_name_right\', \'.\', \'descendant_id\', \' \', \'AS\', \' \', \'category_id\', \',\', \'\\n\', \'    \', \'string_agg\', \'(\', \'redacted_table_name_left\', \'.\', \'name\', \',\', \' \', "\' Ã¢â€ â€™ \'", \' \', \'ORDER\', \' \', \'BY\', \' \', \'reacted_table_name_right\', \'.\', \'generations\', \' \', \'DESC\', \')\', \' \', \'AS\', \' \', \'breadcrumbs\', \' \', \'-- noqa\', \'\\n\', \'FROM\', \' \', \'redacted_schema_name_redacted_table_name_left\', \' \', \'AS\', \' \', \'redacted_table_name_left\', \'\\n\', \'INNER\', \' \', \'JOIN\', \' \', \'redacted_schema_name_reacted_table_name_right\', \' \', \'AS\', \' \', \'reacted_table_name_right\', \'\\n\', \'    \', \'ON\', \' \', \'redacted_table_name_left\', \'.\', \'id\', \' \', \'=\', \' \', \'order_issue_category_hierarchies\', \'.\', \'ancestor_id\', \'\\n\', \'GROUP\', \' \', \'BY\', \' \', \'reacted_table_name_right\', \'.\', \'descendant_id\', \'\\n\']\nINFO       PARSING (reproduce.sql)\nINFO       [PD:0  MD:2 ]\t..StatementSegment                                \tGreed.match OUT     \t++  \t[match=<MatchResult 60/60: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:0  MD:0 ]\tFileSegment                                       \tDelim.match OUT     \t++  \t[match=<MatchResult 1/1: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       \n###\n#\n# Parse Depth 1. Expanding: StatementSegment: \'SELECT\\n    reacted_table_name_right.desc...\'\n#\n###\nINFO       [PD:1  MD:0 ]\tStatementSegment                                  \tOneOf.match PRN     \t    \t[ns=0, ps=28, ms=1, pruned=[<Ref: InsertStatementSegment>, <Ref: TransactionStatementSegment>, <Ref: DropStatementSegment>, <Ref: TruncateStatementSegment>, <Ref: AccessStatementSegment>, <Ref: CreateTableStatementSegment>, <Ref: CreateTypeStatementSegment>, <Ref: CreateRoleStatementSegment>, <Ref: AlterTableStatementSegment>, <Ref: CreateSchemaStatementSegment>, <Ref: SetSchemaStatementSegment>, <Ref: DropSchemaStatementSegment>, <Ref: CreateDatabaseStatementSegment>, <Ref: CreateExtensionStatementSegment>, <Ref: CreateIndexStatementSegment>, <Ref: DropIndexStatementSegment>, <Ref: CreateViewStatementSegment>, <Ref: DeleteStatementSegment>, <Ref: UpdateStatementSegment>, <Ref: CreateFunctionStatementSegment>, <Ref: CreateModelStatementSegment>, <Ref: DropModelStatementSegment>, <Ref: DescribeStatementSegment>, <Ref: UseStatementSegment>, <Ref: ExplainStatementSegment>, <Ref: CreateSequenceStatementSegment>, <Ref: AlterSequenceStatementSegment>, <Ref: DropSequenceStatementSegment>], opts=[<Ref: SelectableGrammar>]]\nINFO       [PD:1  MD:1 ]\t.SelectableGrammar                                \tOneOf.match PRN     \t    \t[ns=0, ps=1, ms=1, pruned=[<Ref: WithCompoundStatementSegment>], opts=[<Ref: NonWithSelectableGrammar>]]\nINFO       [PD:1  MD:2 ]\t..NonWithSelectableGrammar                        \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=3, pruned=[], opts=[<Ref: SetExpressionSegment>, <OptionallyBracketed: [<Bracketed: [<Ref: SelectStatementSegmen..., <Ref: SelectStatementSegment>]>, <Ref: NonSetSelectableGrammar>]]\nINFO       [PD:1  MD:5 ]\t.....NonSetSelectableGrammar                      \tOneOf.match PRN     \t    \t[ns=0, ps=2, ms=1, pruned=[<Ref: ValuesClauseSegment>, <Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: UnorderedSelectStatementSegment>]]\nINFO       [PD:1  MD:15]\t...............WildcardIdentifierSegment          \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:1  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:1  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/57: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:16]\t................WildcardIdentifierSegment         \tSeque.match OUT     \t+   \t[match=<MatchResult 2/57: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:15]\t...............WildcardIdentifierSegment          \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:1  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:1  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/55: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:1  MD:16]\t................WildcardIdentifierSegment         \tSeque.match OUT     \t    \t[match=<MatchResult 0/55: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:1  MD:15]\t...............WildcardIdentifierSegment          \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/57: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:14]\t..............WildcardIdentifierSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/57: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:12]\t............WildcardExpressionSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/57: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:10]\t..........SelectClauseSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/60: \'SELECT\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:10]\t..........SelectClauseSegment                     \tOneOf.match PRN     \t    \t[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Sequence: [<Ref: OrderKeywordSegment>, <Ref: ByKeywordSegment>]>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]\nINFO       [PD:1  MD:10]\t..........SelectClauseSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/38: \'FROM\'>, seg="\'FROM redacted_schema...\'"]\nINFO       [PD:1  MD:9 ]\t.........SelectClauseSegment                      \tStart.match OUT     \t+   \t[match=<MatchResult 19/60: \'SELECT\\n    reac... AS breadcrumbs\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:7 ]\t.......UnorderedSelectStatementSegment            \tStart.match OUT     \t++  \t[match=<MatchResult 42/42: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:5 ]\t.....NonSetSelectableGrammar                      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:4 ]\t....SetExpressionSegment                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/60: \'\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:3 ]\t...NonWithSelectableGrammar                       \tOptio.match PRN     \t    \t[ns=0, ps=1, ms=1, pruned=[<Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: SelectStatementSegment>]]\nINFO       [PD:1  MD:13]\t.............WildcardIdentifierSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:1  MD:15]\t...............SingleIdentifierGrammar            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:1  MD:15]\t...............SingleIdentifierGrammar            \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/57: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:14]\t..............WildcardIdentifierSegment           \tSeque.match OUT     \t+   \t[match=<MatchResult 2/57: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:13]\t.............WildcardIdentifierSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:1  MD:15]\t...............SingleIdentifierGrammar            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:1  MD:15]\t...............SingleIdentifierGrammar            \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/55: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:1  MD:14]\t..............WildcardIdentifierSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/55: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:1  MD:13]\t.............WildcardIdentifierSegment            \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/57: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:12]\t............WildcardIdentifierSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/57: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:10]\t..........WildcardExpressionSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/57: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:1  MD:8 ]\t........SelectClauseSegment                       \tSeque.match OUT     \t+   \t[match=<MatchResult 1/60: \'SELECT\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:8 ]\t........SelectClauseSegment                       \tOneOf.match PRN     \t    \t[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Sequence: [<Ref: OrderKeywordSegment>, <Ref: ByKeywordSegment>]>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]\nINFO       [PD:1  MD:8 ]\t........SelectClauseSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/38: \'FROM\'>, seg="\'FROM redacted_schema...\'"]\nINFO       [PD:1  MD:7 ]\t.......SelectClauseSegment                        \tStart.match OUT     \t+   \t[match=<MatchResult 19/60: \'SELECT\\n    reac... AS breadcrumbs\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:5 ]\t.....SelectStatementSegment                       \tStart.match OUT     \t++  \t[match=<MatchResult 42/42: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:3 ]\t...NonWithSelectableGrammar                       \tOptio.match OUT     \t++  \t[match=<MatchResult 1/1: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:2 ]\t..NonWithSelectableGrammar                        \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:1 ]\t.SelectableGrammar                                \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:1  MD:0 ]\tStatementSegment                                  \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       \n###\n#\n# Parse Depth 2. Expanding: SelectStatementSegment: \'SELECT\\n    reacted_table_name_right.desc...\'\n#\n###\nINFO       [PD:2  MD:1 ]\t.SelectClauseSegment                              \tSelec._match SELF   \t+++ \nINFO       [PD:2  MD:3 ]\t...FromClauseTerminatorGrammar                    \tOneOf.match PRN     \t    \t[ns=0, ps=8, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Sequence: [<Ref: OrderKeywordSegment>, <Ref: ByKeywordSegment>]>, <Ref: HavingKeywordSegment>, <Ref: QualifyKeywordSegment>, <Ref: WindowKeywordSegment>, <Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>], opts=[<Sequence: [<Ref: GroupKeywordSegment>, <Ref: ByKeywordSegment>]>]]\nINFO       [PD:2  MD:4 ]\t....FromClauseTerminatorGrammar                   \tSeque.match OUT     \t+   \t[match=<MatchResult 3/7: \'GROUP BY\'>, seg="\'GROUP BY reacted_tab...\'"]\nINFO       [PD:2  MD:3 ]\t...FromClauseTerminatorGrammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/7: \'GROUP BY\'>, seg="\'GROUP BY reacted_tab...\'"]\nINFO       [PD:2  MD:2 ]\t..FromClauseSegment                               \tStart.match OUT     \t+   \t[match=<MatchResult 30/38: \'FROM redacted_s...ies.ancestor_id\'>, seg="\'FROM redacted_schema...\'"]\nINFO       [PD:2  MD:2 ]\t..WhereClauseSegment                              \tStart.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'GROUP BY reacted_tab...\'"]\nINFO       [PD:2  MD:3 ]\t...GroupByClauseSegment                           \tSeque.match OUT     \t+   \t[match=<MatchResult 3/7: \'GROUP BY\'>, seg="\'GROUP BY reacted_tab...\'"]\nINFO       [PD:2  MD:2 ]\t..GroupByClauseSegment                            \tStart.match OUT     \t++  \t[match=<MatchResult 7/7: \'GROUP BY reacte...t.descendant_id\'>, seg="\'GROUP BY reacted_tab...\'"]\nINFO       [PD:2  MD:0 ]\tSelectStatementSegment                            \tSeque.match OUT     \t++  \t[match=<MatchResult 8/8: \'SELECT\\n    reac...t.descendant_id\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       \n###\n#\n# Parse Depth 3. Expanding: SelectClauseSegment: \'SELECT\\n    reacted_table_name_right.desc...\'\n#\n###\nINFO       [PD:3  MD:2 ]\t..SelectClauseModifierSegment                     \tOneOf.match PRN     \t    \t[ns=0, ps=2, ms=0, pruned=[<Ref: DistinctKeywordSegment>, <Ref: AllKeywordSegment>], opts=\'ALL\']\nINFO       [PD:3  MD:2 ]\t..SelectClauseModifierSegment                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:3 ]\t...SelectClauseElementSegment                     \tGreed.match OUT     \t++  \t[match=<MatchResult 7/7: \'reacted_table_n... AS category_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:3 ]\t...SelectClauseElementSegment                     \tGreed.match OUT     \t++  \t[match=<MatchResult 6/6: \'string_agg(reda... AS breadcrumbs\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:3  MD:1 ]\t.SelectClauseSegmentGrammar                       \tDelim.match OUT     \t++  \t[match=<MatchResult 5/5: \'reacted_table_n... AS breadcrumbs\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:0 ]\tSelectClauseSegmentGrammar                        \tSeque.match OUT     \t++  \t[match=<MatchResult 9/9: \'SELECT\\n    reac... AS breadcrumbs\'>, seg="\'SELECT\\\\n    reacted_t...\'"]\nINFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  1, P:  1]) \'SELECT\'>...\nINFO       [PD:4] Skipping expansion of <Indent: ([L:  1, P:  7]) \'\'>...\nINFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  1, P:  7]) \'\\n\'>...\nINFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  2, P:  1]) \'    \'>...\nINFO       \n###\n#\n# Parse Depth 4. Expanding: SelectClauseElementSegment: \'reacted_table_name_right.descendant_id A...\'\n#\n###\nINFO       [PD:4  MD:0 ]\tSelectClauseElementSegment                        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]\nINFO       [PD:4  MD:5 ]\t.....WildcardIdentifierSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:7 ]\t.......SingleIdentifierGrammar                    \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:7 ]\t.......SingleIdentifierGrammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:6 ]\t......WildcardIdentifierSegment                   \tSeque.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....WildcardIdentifierSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:7 ]\t.......SingleIdentifierGrammar                    \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:7 ]\t.......SingleIdentifierGrammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:6 ]\t......WildcardIdentifierSegment                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:5 ]\t.....WildcardIdentifierSegment                    \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:4 ]\t....WildcardIdentifierSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:2 ]\t..WildcardExpressionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:2 ]\t..BaseExpressionElementGrammar                    \tOneOf.match PRN     \t    \t[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]\nINFO       [PD:4  MD:3 ]\t...LiteralGrammar                                 \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:3 ]\t...LiteralGrammar                                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:4 ]\t....FunctionSegment                               \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:4  MD:9 ]\t.........DatePartFunctionNameSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:7 ]\t.......FunctionSegment                            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:11]\t...........FunctionNameSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:11]\t...........FunctionNameSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:9 ]\t.........FunctionNameSegment                      \tSeque.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:7 ]\t.......FunctionSegment                            \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:7 ]\t.......FunctionSegment                            \tBrack.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:6 ]\t......FunctionSegment                             \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....FunctionSegment                              \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:4 ]\t....FunctionSegment                               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:6 ]\t......ColumnReferenceSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'.\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:6 ]\t......ColumnReferenceSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'.\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: AsKeywordSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\' AS category_id\'"]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\' AS category_id\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\' AS category_id\'"]\nINFO       [PD:4  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'descendant_id\'>, seg="\'descendant_id\'"]\nINFO       [PD:4  MD:4 ]\t....ColumnReferenceSegment                        \tDelim.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:4  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:4  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:4  MD:12]\t............FunctionSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:4  MD:17]\t.................DatePartFunctionNameSegment      \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:15]\t...............FunctionSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'descendant_id\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:15]\t...............FunctionSegment                    \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:15]\t...............FunctionSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:12]\t............FunctionSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:11]\t...........LiteralGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:11]\t...........LiteralGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'.\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'.\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'.descendant_id AS ca...\'"]\nINFO       [PD:4  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'descendant_id AS cat...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: AsKeywordSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\' AS category_id\'"]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\' AS category_id\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\' AS category_id\'"]\nINFO       [PD:4  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'descendant_id\'>, seg="\'descendant_id\'"]\nINFO       [PD:4  MD:12]\t............ColumnReferenceSegment                \tDelim.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............ArrayLiteralSegment                  \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............DatatypeSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:4  MD:15]\t...............DatatypeSegment                    \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:4  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t+   \t[match=<MatchResult 2/7: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:16]\t................DatatypeSegment                   \tSeque.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:15]\t...............DatatypeSegment                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:15]\t...............DatatypeSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:14]\t..............DatatypeSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:13]\t.............DatatypeSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/7: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:12]\t............Expression_D_Grammar                  \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:12]\t............Expression_D_Grammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:10]\t..........Accessor_Grammar                        \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:4  MD:10]\t..........Accessor_Grammar                        \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:7 ]\t.......Expression_C_Grammar                       \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:4  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:4  MD:8 ]\t........Expression_A_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:4  MD:10]\t..........BinaryOperatorGrammar                   \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:11]\t...........ComparisonOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:11]\t...........ComparisonOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:10]\t..........BinaryOperatorGrammar                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:9 ]\t.........Expression_A_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:8 ]\t........Expression_A_Grammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:7 ]\t.......Expression_A_Grammar                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:4 ]\t....Expression_A_Grammar                          \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:2 ]\t..BaseExpressionElementGrammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:4 ]\t....AliasExpressionSegment                        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]\nINFO       [PD:4  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'category_id\'>, seg="\'category_id\'"]\nINFO       [PD:4  MD:5 ]\t.....AliasExpressionSegment                       \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'category_id\'>, seg="\'category_id\'"]\nINFO       [PD:4  MD:4 ]\t....AliasExpressionSegment                        \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'category_id\'>, seg="\'category_id\'"]\nINFO       [PD:4  MD:3 ]\t...AliasExpressionSegment                         \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'AS category_id\'>, seg="\'AS category_id\'"]\nINFO       [PD:4  MD:1 ]\t.SelectClauseElementSegment                       \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'reacted_table_n... AS category_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:4  MD:0 ]\tSelectClauseElementSegment                        \tOneOf.match OUT     \t++  \t[match=<MatchResult 3/3: \'reacted_table_n... AS category_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  2, P:  5])>...\nINFO       [PD:5] Skipping expansion of <WhitespaceSegment: ([L:  2, P: 43]) \' \'>...\nINFO       [PD:5] Skipping expansion of <AliasExpressionSegment: ([L:  2, P: 44])>...\nINFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  2, P: 58]) \',\'>...\nINFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  2, P: 59]) \'\\n\'>...\nINFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P:  1]) \'    \'>...\nINFO       \n###\n#\n# Parse Depth 4. Expanding: SelectClauseElementSegment: \'string_agg(redacted_table_name_left.name...\'\n#\n###\nINFO       [PD:4  MD:0 ]\tSelectClauseElementSegment                        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]\nINFO       [PD:4  MD:5 ]\t.....WildcardIdentifierSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:7 ]\t.......SingleIdentifierGrammar                    \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:7 ]\t.......SingleIdentifierGrammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:6 ]\t......WildcardIdentifierSegment                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....WildcardIdentifierSegment                    \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:4 ]\t....WildcardIdentifierSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:2 ]\t..WildcardExpressionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:2 ]\t..BaseExpressionElementGrammar                    \tOneOf.match PRN     \t    \t[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]\nINFO       [PD:4  MD:3 ]\t...LiteralGrammar                                 \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:3 ]\t...LiteralGrammar                                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:4 ]\t....FunctionSegment                               \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:4  MD:9 ]\t.........DatePartFunctionNameSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:7 ]\t.......FunctionSegment                            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:11]\t...........FunctionNameSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:10]\t..........FunctionNameSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:9 ]\t.........FunctionNameSegment                      \tSeque.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:7 ]\t.......FunctionSegment                            \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:8 ]\t........FunctionSegment                           \tBrack.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_...enerations DESC\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:7 ]\t.......FunctionSegment                            \tBrack.match OUT     \t+   \t[match=<MatchResult 1/5: \'(redacted_table...nerations DESC)\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:6 ]\t......FunctionSegment                             \tSeque.match OUT     \t+   \t[match=<MatchResult 2/6: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:6 ]\t......PostFunctionGrammar                         \tOneOf.match PRN     \t    \t[ns=0, ps=2, ms=0, pruned=[<Ref: OverClauseSegment>, <Ref: FilterClauseGrammar>], opts=\'ALL\']\nINFO       [PD:4  MD:6 ]\t......PostFunctionGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:5 ]\t.....FunctionSegment                              \tSeque.match OUT     \t+   \t[match=<MatchResult 2/6: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:4 ]\t....FunctionSegment                               \tOneOf.match OUT     \t+   \t[match=<MatchResult 2/6: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=8, ms=2, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>], opts=[<Ref: StartBracketSegment>, <Ref: BinaryOperatorGrammar>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>]]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'(redacted_table...nerations DESC)\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'string_agg\'>, seg="\'string_agg\'"]\nINFO       [PD:4  MD:4 ]\t....ColumnReferenceSegment                        \tDelim.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:4  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:4  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:4  MD:12]\t............FunctionSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:4  MD:17]\t.................DatePartFunctionNameSegment      \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:15]\t...............FunctionSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:18]\t..................FunctionNameSegment             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:15]\t...............FunctionSegment                    \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:16]\t................FunctionSegment                   \tBrack.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_...enerations DESC\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:15]\t...............FunctionSegment                    \tBrack.match OUT     \t+   \t[match=<MatchResult 1/5: \'(redacted_table...nerations DESC)\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 2/6: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:14]\t..............PostFunctionGrammar                 \tOneOf.match PRN     \t    \t[ns=0, ps=2, ms=0, pruned=[<Ref: OverClauseSegment>, <Ref: FilterClauseGrammar>], opts=\'ALL\']\nINFO       [PD:4  MD:14]\t..............PostFunctionGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t+   \t[match=<MatchResult 2/6: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:12]\t............FunctionSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 2/6: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:11]\t...........LiteralGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:11]\t...........LiteralGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=8, ms=2, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>], opts=[<Ref: StartBracketSegment>, <Ref: BinaryOperatorGrammar>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>]]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'(redacted_table...nerations DESC)\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'string_agg\'>, seg="\'string_agg\'"]\nINFO       [PD:4  MD:12]\t............ColumnReferenceSegment                \tDelim.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:13]\t.............ArrayLiteralSegment                  \tBrack.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:13]\t.............DatatypeSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:4  MD:15]\t...............DatatypeSegment                    \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:4  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:16]\t................DatatypeSegment                   \tSeque.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:15]\t...............DatatypeSegment                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:17]\t.................DatatypeSegment                  \tOneOf.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Delimited: [<Ref: ExpressionSegment>]>]]\nINFO       [PD:4  MD:21]\t.....................Expression_A_Grammar         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:4  MD:22]\t......................Expression_C_Grammar        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:4  MD:24]\t........................Expression_C_Grammar      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:4  MD:26]\t..........................Expression_D_Grammar    \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:4  MD:28]\t............................FunctionSegment       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:4  MD:33]\t.................................DatePartFunctionNameSegment\tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:31]\t...............................FunctionSegment    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:4  MD:34]\t..................................FunctionNameSegment\tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:4  MD:36]\t....................................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:36]\t....................................SingleIdentifierGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:35]\t...................................FunctionNameSegment\tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:34]\t..................................FunctionNameSegment\tAnyNu.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:34]\t..................................FunctionNameSegment\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:34]\t..................................FunctionNameSegment\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:33]\t.................................FunctionNameSegment\tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:31]\t...............................FunctionSegment    \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:30]\t..............................FunctionSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................FunctionSegment      \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:28]\t............................FunctionSegment       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:27]\t...........................LiteralGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:27]\t...........................LiteralGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................ColumnReferenceSegment\tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:4  MD:30]\t..............................BinaryOperatorGrammar\tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:31]\t...............................ComparisonOperatorGrammar\tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:31]\t...............................ComparisonOperatorGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:30]\t..............................BinaryOperatorGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................ColumnReferenceSegment\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:29]\t.............................SingleIdentifierGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:28]\t............................ColumnReferenceSegment\tDelim.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................ArrayLiteralSegment  \tBrack.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:27]\t...........................Expression_D_Grammar   \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................DatatypeSegment      \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:4  MD:31]\t...............................DatatypeSegment    \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:4  MD:34]\t..................................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:34]\t..................................SingleIdentifierGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:33]\t.................................DatatypeSegment  \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:32]\t................................DatatypeSegment   \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:31]\t...............................DatatypeSegment    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:30]\t..............................DatatypeSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:29]\t.............................DatatypeSegment      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:27]\t...........................Expression_D_Grammar   \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:26]\t..........................Expression_D_Grammar    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:25]\t.........................Expression_D_Grammar     \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:24]\t........................Expression_C_Grammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:23]\t.......................Expression_C_Grammar       \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:22]\t......................Expression_C_Grammar        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:21]\t.....................Expression_A_Grammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:20]\t....................Expression_A_Grammar          \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:18]\t..................DatatypeSegment                 \tDelim.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:17]\t.................DatatypeSegment                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:16]\t................DatatypeSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:4  MD:15]\t...............DatatypeSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:14]\t..............DatatypeSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:13]\t.............DatatypeSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/6: \'string_agg\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:12]\t............Expression_D_Grammar                  \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:4  MD:12]\t............Expression_D_Grammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'(redacted_table_name...\'"]\nINFO       [PD:4  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:10]\t..........Accessor_Grammar                        \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:4  MD:10]\t..........Accessor_Grammar                        \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:4  MD:8 ]\t........Expression_C_Grammar                      \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:7 ]\t.......Expression_C_Grammar                       \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:4  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:4  MD:8 ]\t........Expression_A_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:4  MD:10]\t..........BinaryOperatorGrammar                   \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:4  MD:11]\t...........ComparisonOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:4  MD:11]\t...........ComparisonOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:10]\t..........BinaryOperatorGrammar                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:9 ]\t.........Expression_A_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:8 ]\t........Expression_A_Grammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:7 ]\t.......Expression_A_Grammar                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:5 ]\t.....Expression_A_Grammar                         \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:4 ]\t....Expression_A_Grammar                          \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:2 ]\t..BaseExpressionElementGrammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'string_agg(reda...nerations DESC)\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:4 ]\t....AliasExpressionSegment                        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]\nINFO       [PD:4  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:4  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'breadcrumbs\'>, seg="\'breadcrumbs\'"]\nINFO       [PD:4  MD:5 ]\t.....AliasExpressionSegment                       \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'breadcrumbs\'>, seg="\'breadcrumbs\'"]\nINFO       [PD:4  MD:4 ]\t....AliasExpressionSegment                        \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'breadcrumbs\'>, seg="\'breadcrumbs\'"]\nINFO       [PD:4  MD:3 ]\t...AliasExpressionSegment                         \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'AS breadcrumbs\'>, seg="\'AS breadcrumbs\'"]\nINFO       [PD:4  MD:1 ]\t.SelectClauseElementSegment                       \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'string_agg(reda... AS breadcrumbs\'>, seg="\'string_agg(redacted_...\'"]\nINFO       [PD:4  MD:0 ]\tSelectClauseElementSegment                        \tOneOf.match OUT     \t++  \t[match=<MatchResult 3/3: \'string_agg(reda... AS breadcrumbs\'>, seg="\'string_agg(redacted_...\'"]\nINFO       \n###\n#\n# Parse Depth 5. Expanding: FunctionSegment: \'string_agg(redacted_table_name_left.name...\'\n#\n###\nINFO       [PD:6] Skipping expansion of <FunctionNameSegment: ([L:  3, P:  5])>...\nINFO       \n###\n#\n# Parse Depth 6. Expanding: BracketedSegment: "(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ..."\n#\n###\nINFO       [PD:7] Skipping expansion of <SymbolSegment: ([L:  3, P: 15]) \'(\'>...\nINFO       [PD:7] Skipping expansion of <Indent: ([L:  3, P: 16]) \'\'>...\nINFO       \n###\n#\n# Parse Depth 7. Expanding: EphemeralSegment: "redacted_table_name_left.name, \' Ã¢â€ â€™ \' O..."\n#\n###\nINFO       [PD:7  MD:0 ]\tFunctionContentsGrammar                           \tAnyNu.match PRN     \t    \t[ns=5, ps=3, ms=0, pruned=[<Ref: OrderByClauseSegment>, <Sequence: [<Ref: SeparatorKeywordSegment>, <Ref: LiteralGrammar>]>, <Sequence: [<OneOf: [<Ref: IgnoreKeywordSegment>, <R..., <Ref: NullsKeywordSegment>]>], opts=[<Ref: ExpressionSegment>, <Sequence: [<Ref: ExpressionSegment>, <Ref: AsKeywordSegment>, <Ref: DatatypeSegment>]>, <Sequence: [<OneOf: [<Ref: DatetimeUnitSegment>, <Re..., <Ref: FromKeywordSegment>, <Ref: ExpressionSegment>]>, <Sequence: [<Ref: DistinctKeywordSegment [opt]>, <OneOf: [<Ref: StarSegment>, <Delimited:...]>, <Sequence: [<OneOf: [<Ref: QuotedLiteralSegment>, <R..., <Ref: InKeywordSegment>, <OneOf: [<Ref: QuotedLiteralSe...]>]]\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:4 ]\t....Expression_C_Grammar                          \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:8 ]\t........Expression_D_Grammar                      \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:10]\t..........FunctionSegment                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:15]\t...............DatePartFunctionNameSegment        \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'name\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'name\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:15]\t...............FunctionNameSegment                \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tBrack.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........FunctionSegment                        \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........FunctionSegment                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:9 ]\t.........LiteralGrammar                           \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:9 ]\t.........LiteralGrammar                           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/15: \'.\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/15: \'.\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: CommaSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/13: \',\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'name\'>, seg="\'name\'"]\nINFO       [PD:7  MD:10]\t..........ColumnReferenceSegment                  \tDelim.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........ArrayLiteralSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........DatatypeSegment                        \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:16]\t................SingleIdentifierGrammar           \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:16]\t................SingleIdentifierGrammar           \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tBrack.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:12]\t............DatatypeSegment                       \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........DatatypeSegment                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_D_Grammar                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:8 ]\t........Accessor_Grammar                          \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:8 ]\t........Accessor_Grammar                          \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:7 ]\t.......Expression_D_Grammar                       \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:5 ]\t.....Expression_C_Grammar                         \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_C_Grammar                          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:7  MD:8 ]\t........BinaryOperatorGrammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:9 ]\t.........ComparisonOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:9 ]\t.........ComparisonOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:8 ]\t........BinaryOperatorGrammar                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:7 ]\t.......Expression_A_Grammar                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tSeque.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:2 ]\t..Expression_A_Grammar                            \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:5 ]\t.....Expression_C_Grammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:11]\t...........FunctionSegment                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:16]\t................DatePartFunctionNameSegment       \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'name\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'name\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tBrack.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........FunctionSegment                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........LiteralGrammar                          \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:10]\t..........LiteralGrammar                          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/15: \'.\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/15: \'.\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: CommaSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/13: \',\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'name\'>, seg="\'name\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tDelim.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............ArrayLiteralSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............DatatypeSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tSeque.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tBrack.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............DatatypeSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:9 ]\t.........Accessor_Grammar                         \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:9 ]\t.........Accessor_Grammar                         \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:8 ]\t........Expression_D_Grammar                      \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_C_Grammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_A_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:7  MD:9 ]\t.........BinaryOperatorGrammar                    \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:10]\t..........ComparisonOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:10]\t..........ComparisonOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:9 ]\t.........BinaryOperatorGrammar                    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:8 ]\t........Expression_A_Grammar                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:7 ]\t.......Expression_A_Grammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tSeque.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: DatetimeUnitSegment>, <Ref: ExpressionSegment>]]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:17]\t.................DatePartFunctionNameSegment      \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'name\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'name\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........LiteralGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:11]\t...........LiteralGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/15: \'.\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/15: \'.\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/15: \'\'>, seg=\'".name, \\\' Ã¢â€ â€™ \\\' ORDER..."\']\nINFO       [PD:7  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/14: \'\'>, seg=\'"name, \\\' Ã¢â€ â€™ \\\' ORDER ..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: CommaSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/13: \',\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'name\'>, seg="\'name\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tDelim.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............ArrayLiteralSegment                  \tBrack.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t+   \t[match=<MatchResult 2/16: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........Accessor_Grammar                        \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:10]\t..........Accessor_Grammar                        \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:7  MD:8 ]\t........Expression_A_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:7  MD:10]\t..........BinaryOperatorGrammar                   \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:11]\t...........ComparisonOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:11]\t...........ComparisonOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:10]\t..........BinaryOperatorGrammar                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:9 ]\t.........Expression_A_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:8 ]\t........Expression_A_Grammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:7 ]\t.......Expression_A_Grammar                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/13: \'\'>, seg=\'", \\\' Ã¢â€ â€™ \\\' ORDER BY r..."\']\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: StarSegment>], opts=[<Delimited: [<Ref: FunctionContentsExpressionGrammar>]>]]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:18]\t..................DatePartFunctionNameSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:20]\t....................FunctionNameSegment           \tSeque.match OUT     \t+   \t[match=<MatchResult 2/3: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'name\'>, seg="\'name\'"]\nINFO       [PD:7  MD:20]\t....................FunctionNameSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'name\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/3: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'name\'>, seg="\'name\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tAnyNu.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:12]\t............LiteralGrammar                        \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:12]\t............LiteralGrammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.name\'"]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'name\'"]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'name\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'name\'"]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'name\'>, seg="\'name\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tDelim.match OUT     \t++  \t[match=<MatchResult 3/3: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left.name\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:18]\t..................DatePartFunctionNameSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:20]\t....................FunctionNameSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:12]\t............LiteralGrammar                        \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:12]\t............LiteralGrammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/10: \'\'>, seg="\' ORDER BY reacted_ta...\'"]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/10: \'\'>, seg="\' ORDER BY reacted_ta...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/10: \'\'>, seg="\' ORDER BY reacted_ta...\'"]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\'"\']\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tDelim.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............ArrayLiteralSegment                 \tBrack.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:18]\t..................DatatypeSegment                 \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:11]\t...........Accessor_Grammar                       \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:11]\t...........Accessor_Grammar                       \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tSeque.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_A_Grammar                       \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:7  MD:9 ]\t.........Expression_A_Grammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:7  MD:11]\t...........BinaryOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............ComparisonOperatorGrammar             \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:12]\t............ComparisonOperatorGrammar             \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........BinaryOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_A_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_A_Grammar                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_A_Grammar                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_A_Grammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tSeque.match OUT     \t+   \t[match=<MatchResult 1/11: "\' Ã¢â€ â€™ \'">, seg=\'"\\\' Ã¢â€ â€™ \\\' ORDER BY rea..."\']\nINFO       [PD:7  MD:3 ]\t...FunctionContentsGrammar                        \tDelim.match OUT     \t+   \t[match=<MatchResult 4/14: "redacted_table_...t.name, \' Ã¢â€ â€™ \'">, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 4/14: "redacted_table_...t.name, \' Ã¢â€ â€™ \'">, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t+   \t[match=<MatchResult 4/14: "redacted_table_...t.name, \' Ã¢â€ â€™ \'">, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: QuotedLiteralSegment>, <Ref: SingleIdentifierGrammar>]]\nINFO       [PD:7  MD:3 ]\t...SingleIdentifierGrammar                        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:3 ]\t...SingleIdentifierGrammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/16: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:7  MD:0 ]\tFunctionContentsGrammar                           \tAnyNu.match PRN     \t    \t[ns=5, ps=2, ms=1, pruned=[<Sequence: [<Ref: SeparatorKeywordSegment>, <Ref: LiteralGrammar>]>, <Sequence: [<OneOf: [<Ref: IgnoreKeywordSegment>, <R..., <Ref: NullsKeywordSegment>]>], opts=[<Ref: ExpressionSegment>, <Sequence: [<Ref: ExpressionSegment>, <Ref: AsKeywordSegment>, <Ref: DatatypeSegment>]>, <Sequence: [<OneOf: [<Ref: DatetimeUnitSegment>, <Re..., <Ref: FromKeywordSegment>, <Ref: ExpressionSegment>]>, <Sequence: [<Ref: DistinctKeywordSegment [opt]>, <OneOf: [<Ref: StarSegment>, <Delimited:...]>, <Ref: OrderByClauseSegment>, <Sequence: [<OneOf: [<Ref: QuotedLiteralSegment>, <R..., <Ref: InKeywordSegment>, <OneOf: [<Ref: QuotedLiteralSe...]>]]\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:4 ]\t....Expression_C_Grammar                          \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:8 ]\t........Expression_D_Grammar                      \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:10]\t..........FunctionSegment                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:15]\t...............DatePartFunctionNameSegment        \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionNameSegment                \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........FunctionSegment                        \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........FunctionSegment                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:9 ]\t.........LiteralGrammar                           \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:9 ]\t.........LiteralGrammar                           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:13]\t.............ComparisonOperatorGrammar            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:12]\t............BinaryOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ORDER\'"]\nINFO       [PD:7  MD:10]\t..........ColumnReferenceSegment                  \tDelim.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........ArrayLiteralSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........DatatypeSegment                        \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:16]\t................SingleIdentifierGrammar           \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:16]\t................SingleIdentifierGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:12]\t............DatatypeSegment                       \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........DatatypeSegment                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_D_Grammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_D_Grammar                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_C_Grammar                         \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_C_Grammar                          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:2 ]\t..Expression_A_Grammar                            \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:5 ]\t.....Expression_C_Grammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:11]\t...........FunctionSegment                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:16]\t................DatePartFunctionNameSegment       \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................FunctionNameSegment               \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........FunctionSegment                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........LiteralGrammar                          \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:10]\t..........LiteralGrammar                          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ORDER\'"]\nINFO       [PD:7  MD:11]\t...........ColumnReferenceSegment                 \tDelim.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............ArrayLiteralSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............DatatypeSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:17]\t.................SingleIdentifierGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............DatatypeSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_D_Grammar                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_C_Grammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:3 ]\t...Expression_A_Grammar                           \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: DatetimeUnitSegment>, <Ref: ExpressionSegment>]]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:17]\t.................DatePartFunctionNameSegment      \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:20]\t....................SingleIdentifierGrammar       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:17]\t.................FunctionNameSegment              \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............FunctionSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........LiteralGrammar                         \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:11]\t...........LiteralGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:15]\t...............ComparisonOperatorGrammar          \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:14]\t..............BinaryOperatorGrammar               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:13]\t.............SingleIdentifierGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ORDER\'"]\nINFO       [PD:7  MD:12]\t............ColumnReferenceSegment                \tDelim.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............ArrayLiteralSegment                  \tBrack.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:18]\t..................SingleIdentifierGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............DatatypeSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_D_Grammar                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_C_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:4 ]\t....Expression_A_Grammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: StarSegment>], opts=[<Delimited: [<Ref: FunctionContentsExpressionGrammar>]>]]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:7  MD:18]\t..................DatePartFunctionNameSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:20]\t....................FunctionNameSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................FunctionNameSegment            \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................FunctionSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:15]\t...............FunctionSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............FunctionSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............LiteralGrammar                        \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:12]\t............LiteralGrammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:7  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:7  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\' BY reacted_table_na...\'"]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ORDER\'"]\nINFO       [PD:7  MD:13]\t.............ColumnReferenceSegment               \tDelim.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............ArrayLiteralSegment                 \tBrack.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:7  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:18]\t..................DatatypeSegment                 \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:16]\t................DatatypeSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:14]\t..............DatatypeSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'ORDER\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:13]\t.............Expression_D_Grammar                 \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:7  MD:13]\t.............Expression_D_Grammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'BY reacted_table_nam...\'"]\nINFO       [PD:7  MD:12]\t............Expression_D_Grammar                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:8 ]\t........Expression_C_Grammar                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:5 ]\t.....Expression_A_Grammar                         \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:3 ]\t...FunctionContentsGrammar                        \tDelim.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:2 ]\t..FunctionContentsGrammar                         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:1 ]\t.FunctionContentsGrammar                          \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:3 ]\t...OrderByClauseSegment                           \tSeque.match OUT     \t+   \t[match=<MatchResult 3/9: \'ORDER BY\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:2 ]\t..OrderByClauseSegment                            \tStart.match OUT     \t++  \t[match=<MatchResult 9/9: \'ORDER BY reacte...enerations DESC\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:7  MD:0 ]\tFunctionContentsGrammar                           \tAnyNu.match OUT     \t++  \t[match=<MatchResult 6/6: \'redacted_table_...enerations DESC\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:8] Skipping expansion of <ExpressionSegment: ([L:  3, P: 16])>...\nINFO       [PD:8] Skipping expansion of <SymbolSegment: ([L:  3, P: 45]) \',\'>...\nINFO       [PD:8] Skipping expansion of <WhitespaceSegment: ([L:  3, P: 46]) \' \'>...\nINFO       [PD:8] Skipping expansion of <ExpressionSegment: ([L:  3, P: 47])>...\nINFO       [PD:8] Skipping expansion of <WhitespaceSegment: ([L:  3, P: 54]) \' \'>...\nINFO       \n###\n#\n# Parse Depth 8. Expanding: OrderByClauseSegment: \'ORDER BY reacted_table_name_right.genera...\'\n#\n###\nINFO       [PD:8  MD:3 ]\t...OrderByClauseSegment                           \tOneOf.match PRN     \t    \t[ns=3, ps=0, ms=0, pruned=[], opts=[<Ref: ColumnReferenceSegment>, <Ref: NumericLiteralSegment>, <Ref: ExpressionSegment>]]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:8  MD:7 ]\t.......ColumnReferenceSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:8  MD:7 ]\t.......ColumnReferenceSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:8 ]\t........ComparisonOperatorGrammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\' DESC\'"]\nINFO       [PD:8  MD:7 ]\t.......BinaryOperatorGrammar                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\' DESC\'"]\nINFO       [PD:8  MD:6 ]\t......ColumnReferenceSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\' DESC\'"]\nINFO       [PD:8  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:6 ]\t......SingleIdentifierGrammar                     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'generations\'>, seg="\'generations\'"]\nINFO       [PD:8  MD:5 ]\t.....ColumnReferenceSegment                       \tDelim.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:8  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:8  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:8  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:8  MD:13]\t.............FunctionSegment                      \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:8  MD:18]\t..................DatePartFunctionNameSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:16]\t................FunctionSegment                   \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:8  MD:19]\t...................FunctionNameSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:8  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:20]\t....................FunctionNameSegment           \tSeque.match OUT     \t+   \t[match=<MatchResult 2/5: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:19]\t...................FunctionNameSegment            \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:8  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:21]\t.....................SingleIdentifierGrammar      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'generations\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:20]\t....................FunctionNameSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:19]\t...................FunctionNameSegment            \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/5: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:19]\t...................FunctionNameSegment            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:19]\t...................FunctionNameSegment            \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'generations\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:16]\t................FunctionSegment                   \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:16]\t................FunctionSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:15]\t...............FunctionSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............FunctionSegment                     \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:13]\t.............FunctionSegment                      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:12]\t............LiteralGrammar                        \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:8  MD:12]\t............LiteralGrammar                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:8  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:8  MD:15]\t...............ColumnReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/4: \'.\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/4: \'\'>, seg="\'.generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'generations DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:16]\t................ComparisonOperatorGrammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\' DESC\'"]\nINFO       [PD:8  MD:15]\t...............BinaryOperatorGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\' DESC\'"]\nINFO       [PD:8  MD:14]\t..............ColumnReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\' DESC\'"]\nINFO       [PD:8  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'generations\'>, seg="\'generations\'"]\nINFO       [PD:8  MD:13]\t.............ColumnReferenceSegment               \tDelim.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............ArrayLiteralSegment                 \tBrack.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:12]\t............Expression_D_Grammar                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............DatatypeSegment                     \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:8  MD:16]\t................DatatypeSegment                   \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:8  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:8  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:18]\t..................DatatypeSegment                 \tSeque.match OUT     \t+   \t[match=<MatchResult 2/5: \'reacted_table_name_right.\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:17]\t.................DatatypeSegment                  \tSeque.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:16]\t................DatatypeSegment                   \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:16]\t................DatatypeSegment                   \tBrack.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:15]\t...............DatatypeSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:14]\t..............DatatypeSegment                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/5: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:13]\t.............Expression_D_Grammar                 \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:8  MD:13]\t.............Expression_D_Grammar                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:12]\t............Expression_D_Grammar                  \tSeque.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:11]\t...........Expression_D_Grammar                   \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:11]\t...........Accessor_Grammar                       \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:8  MD:11]\t...........Accessor_Grammar                       \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:10]\t..........Expression_D_Grammar                    \tSeque.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:9 ]\t.........Expression_C_Grammar                     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:9 ]\t.........Expression_C_Grammar                     \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:8  MD:9 ]\t.........Expression_C_Grammar                     \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:8 ]\t........Expression_C_Grammar                      \tSeque.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:7 ]\t.......Expression_C_Grammar                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:6 ]\t......Expression_A_Grammar                        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:6 ]\t......Expression_A_Grammar                        \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:8  MD:7 ]\t.......Expression_A_Grammar                       \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:8  MD:9 ]\t.........Expression_A_Grammar                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:8  MD:11]\t...........BinaryOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:8  MD:12]\t............ComparisonOperatorGrammar             \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:8  MD:12]\t............ComparisonOperatorGrammar             \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:11]\t...........BinaryOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:10]\t..........Expression_A_Grammar                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:9 ]\t.........Expression_A_Grammar                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:8 ]\t........Expression_A_Grammar                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:7 ]\t.......Expression_A_Grammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:6 ]\t......Expression_A_Grammar                        \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:5 ]\t.....Expression_A_Grammar                         \tSeque.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:3 ]\t...OrderByClauseSegment                           \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'reacted_table_n...ght.generations\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:3 ]\t...OrderByClauseSegment                           \tOneOf.match PRN     \t    \t[ns=0, ps=1, ms=1, pruned=[<Ref: AscKeywordSegment>], opts=[<Ref: DescKeywordSegment>]]\nINFO       [PD:8  MD:3 ]\t...OrderByClauseSegment                           \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'DESC\'>, seg="\'DESC\'"]\nINFO       [PD:8  MD:2 ]\t..OrderByClauseSegment                            \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'reacted_table_n...enerations DESC\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:1 ]\t.OrderByClauseSegment                             \tDelim.match OUT     \t++  \t[match=<MatchResult 3/3: \'reacted_table_n...enerations DESC\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:8  MD:0 ]\tOrderByClauseSegment                              \tSeque.match OUT     \t++  \t[match=<MatchResult 9/9: \'ORDER BY reacte...enerations DESC\'>, seg="\'ORDER BY reacted_tab...\'"]\nINFO       [PD:9] Skipping expansion of <KeywordSegment: ([L:  3, P: 55]) \'ORDER\'>...\nINFO       [PD:9] Skipping expansion of <WhitespaceSegment: ([L:  3, P: 60]) \' \'>...\nINFO       [PD:9] Skipping expansion of <KeywordSegment: ([L:  3, P: 61]) \'BY\'>...\nINFO       [PD:9] Skipping expansion of <Indent: ([L:  3, P: 63]) \'\'>...\nINFO       [PD:9] Skipping expansion of <WhitespaceSegment: ([L:  3, P: 63]) \' \'>...\nINFO       [PD:9] Skipping expansion of <ColumnReferenceSegment: ([L:  3, P: 64])>...\nINFO       [PD:9] Skipping expansion of <WhitespaceSegment: ([L:  3, P:100]) \' \'>...\nINFO       [PD:9] Skipping expansion of <KeywordSegment: ([L:  3, P:101]) \'DESC\'>...\nINFO       [PD:9] Skipping expansion of <Dedent: ([L:  3, P:105]) \'\'>...\nINFO       [PD:7] Skipping expansion of <Dedent: ([L:  3, P:105]) \'\'>...\nINFO       [PD:7] Skipping expansion of <SymbolSegment: ([L:  3, P:105]) \')\'>...\nINFO       [PD:5] Skipping expansion of <WhitespaceSegment: ([L:  3, P:106]) \' \'>...\nINFO       [PD:5] Skipping expansion of <AliasExpressionSegment: ([L:  3, P:107])>...\nINFO       [PD:3] Skipping expansion of <WhitespaceSegment: ([L:  3, P:121]) \' \'>...\nINFO       [PD:3] Skipping expansion of <CommentSegment: ([L:  3, P:122]) \'-- noqa\'>...\nINFO       [PD:3] Skipping expansion of <NewlineSegment: ([L:  3, P:129]) \'\\n\'>...\nINFO       [PD:3] Skipping expansion of <Dedent: ([L:  4, P:  1]) \'\'>...\nINFO       \n###\n#\n# Parse Depth 3. Expanding: FromClauseSegment: \'FROM redacted_schema_name_redacted_table...\'\n#\n###\nINFO       [PD:3  MD:4 ]\t....FromExpressionSegment                         \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: MLTableExpressionSegment>], opts=[<Ref: FromExpressionElementSegment>]]\nINFO       [PD:3  MD:7 ]\t.......FromExpressionElementSegment               \tOptio.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]\nINFO       [PD:3  MD:9 ]\t.........TableExpressionSegment                   \tOneOf.match PRN     \t    \t[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]\nINFO       [PD:3  MD:11]\t...........FunctionSegment                        \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:3  MD:16]\t................DatePartFunctionNameSegment       \tSeque.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:14]\t..............FunctionSegment                     \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:3  MD:17]\t.................FunctionNameSegment              \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:19]\t...................SingleIdentifierGrammar        \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:18]\t..................FunctionNameSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:17]\t.................FunctionNameSegment              \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:17]\t.................FunctionNameSegment              \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:17]\t.................FunctionNameSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:16]\t................FunctionNameSegment               \tSeque.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:14]\t..............FunctionSegment                     \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:14]\t..............FunctionSegment                     \tBrack.match OUT     \t    \t[match=<MatchResult 0/26: \'\'>, seg="\'AS redacted_table_na...\'"]\nINFO       [PD:3  MD:13]\t.............FunctionSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:12]\t............FunctionSegment                       \tSeque.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:11]\t...........FunctionSegment                        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:13]\t.............TableReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:13]\t.............TableReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:13]\t.............TableReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/8: \'.\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:13]\t.............TableReferenceSegment                \tSeque.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/8: \'.\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/28: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: AsKeywordSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:14]\t..............ComparisonOperatorGrammar           \tOneOf.match OUT     \t    \t[match=<MatchResult 0/27: \'\'>, seg="\' AS redacted_table_n...\'"]\nINFO       [PD:3  MD:13]\t.............BinaryOperatorGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/27: \'\'>, seg="\' AS redacted_table_n...\'"]\nINFO       [PD:3  MD:12]\t............TableReferenceSegment                 \tOneOf.match OUT     \t    \t[match=<MatchResult 0/27: \'\'>, seg="\' AS redacted_table_n...\'"]\nINFO       [PD:3  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:12]\t............SingleIdentifierGrammar               \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:11]\t...........TableReferenceSegment                  \tDelim.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:9 ]\t.........TableExpressionSegment                   \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:7 ]\t.......FromExpressionElementSegment               \tOptio.match OUT     \t+   \t[match=<MatchResult 1/28: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:7 ]\t.......FromExpressionElementSegment               \tSeque.match OUT     \t    \t[match=<MatchResult 0/26: \'\'>, seg="\'AS redacted_table_na...\'"]\nINFO       [PD:3  MD:9 ]\t.........AliasExpressionSegment                   \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]\nINFO       [PD:3  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:11]\t...........SingleIdentifierGrammar                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/24: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:11]\t...........AliasExpressionSegment                 \tBrack.match OUT     \t    \t[match=<MatchResult 0/22: \'\'>, seg="\'INNER JOIN redacted_...\'"]\nINFO       [PD:3  MD:10]\t..........AliasExpressionSegment                  \tSeque.match OUT     \t+   \t[match=<MatchResult 1/24: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:9 ]\t.........AliasExpressionSegment                   \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/24: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:8 ]\t........AliasExpressionSegment                    \tSeque.match OUT     \t+   \t[match=<MatchResult 3/26: \'AS redacted_table_name_left\'>, seg="\'AS redacted_table_na...\'"]\nINFO       [PD:3  MD:6 ]\t......FromExpressionElementSegment                \tSeque.match OUT     \t+   \t[match=<MatchResult 3/26: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:4 ]\t....FromExpressionSegment                         \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/24: \'redacted_schema...table_name_left\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:4 ]\t....FromExpressionSegment                         \tCondi.match OUT     \t+   \t[match=<MatchResult 1/23: \'\'>, seg="\'INNER JOIN redacted_...\'"]\nINFO       [PD:3  MD:4 ]\t....FromExpressionSegment                         \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]\nINFO       [PD:3  MD:7 ]\t.......JoinClauseSegment                          \tOneOf.match PRN     \t    \t[ns=0, ps=2, ms=1, pruned=[<Ref: CrossKeywordSegment>, <Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>], opts=[<Ref: InnerKeywordSegment>]]\nINFO       [PD:3  MD:7 ]\t.......JoinClauseSegment                          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/22: \'INNER\'>, seg="\'INNER JOIN redacted_...\'"]\nINFO       [PD:3  MD:7 ]\t.......JoinKeywords                               \tSeque.match OUT     \t+   \t[match=<MatchResult 1/20: \'JOIN\'>, seg="\'JOIN redacted_schema...\'"]\nINFO       [PD:3  MD:10]\t..........FromExpressionElementSegment            \tOptio.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]\nINFO       [PD:3  MD:12]\t............TableExpressionSegment                \tOneOf.match PRN     \t    \t[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]\nINFO       [PD:3  MD:14]\t..............FunctionSegment                     \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:3  MD:19]\t...................DatePartFunctionNameSegment    \tSeque.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:17]\t.................FunctionSegment                  \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:3  MD:20]\t....................FunctionNameSegment           \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:22]\t......................SingleIdentifierGrammar     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:22]\t......................SingleIdentifierGrammar     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:21]\t.....................FunctionNameSegment          \tSeque.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:20]\t....................FunctionNameSegment           \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:20]\t....................FunctionNameSegment           \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:20]\t....................FunctionNameSegment           \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:19]\t...................FunctionNameSegment            \tSeque.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:17]\t.................FunctionSegment                  \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:17]\t.................FunctionSegment                  \tBrack.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'AS reacted_table_nam...\'"]\nINFO       [PD:3  MD:16]\t................FunctionSegment                   \tSeque.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:15]\t...............FunctionSegment                    \tSeque.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:14]\t..............FunctionSegment                     \tOneOf.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:16]\t................TableReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:16]\t................TableReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:16]\t................TableReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/8: \'.\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:16]\t................TableReferenceSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/8: \'.\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:16]\t................BinaryOperatorGrammar             \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:17]\t.................ComparisonOperatorGrammar        \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:17]\t.................ComparisonOperatorGrammar        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:16]\t................BinaryOperatorGrammar             \tOneOf.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/18: \'\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: AsKeywordSegment>, <Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:16]\t................BinaryOperatorGrammar             \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:17]\t.................ComparisonOperatorGrammar        \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:17]\t.................ComparisonOperatorGrammar        \tOneOf.match OUT     \t    \t[match=<MatchResult 0/17: \'\'>, seg="\' AS reacted_table_na...\'"]\nINFO       [PD:3  MD:16]\t................BinaryOperatorGrammar             \tOneOf.match OUT     \t    \t[match=<MatchResult 0/17: \'\'>, seg="\' AS reacted_table_na...\'"]\nINFO       [PD:3  MD:15]\t...............TableReferenceSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/17: \'\'>, seg="\' AS reacted_table_na...\'"]\nINFO       [PD:3  MD:15]\t...............SingleIdentifierGrammar            \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:15]\t...............SingleIdentifierGrammar            \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:14]\t..............TableReferenceSegment               \tDelim.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:12]\t............TableExpressionSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:10]\t..........FromExpressionElementSegment            \tOptio.match OUT     \t+   \t[match=<MatchResult 1/18: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:10]\t..........FromExpressionElementSegment            \tSeque.match OUT     \t    \t[match=<MatchResult 0/16: \'\'>, seg="\'AS reacted_table_nam...\'"]\nINFO       [PD:3  MD:12]\t............AliasExpressionSegment                \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]\nINFO       [PD:3  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:14]\t..............SingleIdentifierGrammar             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:14]\t..............AliasExpressionSegment              \tBrack.match OUT     \t    \t[match=<MatchResult 0/11: \'\'>, seg="\'ON redacted_table_na...\'"]\nINFO       [PD:3  MD:13]\t.............AliasExpressionSegment               \tSeque.match OUT     \t+   \t[match=<MatchResult 1/14: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:12]\t............AliasExpressionSegment                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/14: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:11]\t...........AliasExpressionSegment                 \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'AS reacted_table_name_right\'>, seg="\'AS reacted_table_nam...\'"]\nINFO       [PD:3  MD:9 ]\t.........FromExpressionElementSegment             \tSeque.match OUT     \t+   \t[match=<MatchResult 3/16: \'redacted_schema...able_name_right\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:8 ]\t........JoinClauseSegment                         \tOneOf.match PRN     \t    \t[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class \'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]\nINFO       [PD:3  MD:11]\t...........JoinOnConditionSegment                 \tOptio.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: ExpressionSegment>]>], opts=[<Ref: ExpressionSegment>]]\nINFO       [PD:3  MD:14]\t..............Expression_A_Grammar                \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]\nINFO       [PD:3  MD:15]\t...............Expression_C_Grammar               \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:3  MD:17]\t.................Expression_C_Grammar             \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:3  MD:19]\t...................Expression_D_Grammar           \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:3  MD:21]\t.....................FunctionSegment              \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:3  MD:26]\t..........................DatePartFunctionNameSegment\tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:24]\t........................FunctionSegment           \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:3  MD:27]\t...........................FunctionNameSegment    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:29]\t.............................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:29]\t.............................SingleIdentifierGrammar\tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:28]\t............................FunctionNameSegment   \tSeque.match OUT     \t+   \t[match=<MatchResult 2/9: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:27]\t...........................FunctionNameSegment    \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:29]\t.............................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:29]\t.............................SingleIdentifierGrammar\tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'id\'>, seg="\'id = order_issue_cat...\'"]\nINFO       [PD:3  MD:28]\t............................FunctionNameSegment   \tSeque.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'id = order_issue_cat...\'"]\nINFO       [PD:3  MD:27]\t...........................FunctionNameSegment    \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/9: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:27]\t...........................FunctionNameSegment    \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:27]\t...........................FunctionNameSegment    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'id\'>, seg="\'id = order_issue_cat...\'"]\nINFO       [PD:3  MD:26]\t..........................FunctionNameSegment     \tSeque.match OUT     \t+   \t[match=<MatchResult 3/9: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:24]\t........................FunctionSegment           \tAnyNu.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:24]\t........................FunctionSegment           \tBrack.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:23]\t.......................FunctionSegment            \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................FunctionSegment             \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:21]\t.....................FunctionSegment              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:20]\t....................LiteralGrammar                \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:3  MD:20]\t....................LiteralGrammar                \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/8: \'.\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/8: \'.\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/8: \'\'>, seg="\'.id = order_issue_ca...\'"]\nINFO       [PD:3  MD:22]\t......................SingleIdentifierGrammar     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:22]\t......................SingleIdentifierGrammar     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'id = order_issue_cat...\'"]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'id = order_issue_cat...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/7: \'\'>, seg="\'id = order_issue_cat...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match PRN     \t    \t[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:24]\t........................ComparisonOperatorGrammar \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\' = order_issue_categ...\'"]\nINFO       [PD:3  MD:23]\t.......................BinaryOperatorGrammar      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\' = order_issue_categ...\'"]\nINFO       [PD:3  MD:22]\t......................ColumnReferenceSegment      \tOneOf.match OUT     \t    \t[match=<MatchResult 0/6: \'\'>, seg="\' = order_issue_categ...\'"]\nINFO       [PD:3  MD:22]\t......................SingleIdentifierGrammar     \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:22]\t......................SingleIdentifierGrammar     \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'id\'>, seg="\'id\'"]\nINFO       [PD:3  MD:21]\t.....................ColumnReferenceSegment       \tDelim.match OUT     \t+   \t[match=<MatchResult 3/9: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................ArrayLiteralSegment         \tBrack.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:20]\t....................Expression_D_Grammar          \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................DatatypeSegment             \tOneOf.match PRN     \t    \t[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]\nINFO       [PD:3  MD:24]\t........................DatatypeSegment           \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]\nINFO       [PD:3  MD:27]\t...........................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:27]\t...........................SingleIdentifierGrammar\tOneOf.match OUT     \t+   \t[match=<MatchResult 1/9: \'redacted_table_name_left\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:26]\t..........................DatatypeSegment         \tSeque.match OUT     \t+   \t[match=<MatchResult 2/9: \'redacted_table_name_left.\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:25]\t.........................DatatypeSegment          \tSeque.match OUT     \t+   \t[match=<MatchResult 3/9: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:24]\t........................DatatypeSegment           \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/9: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:24]\t........................DatatypeSegment           \tBrack.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:23]\t.......................DatatypeSegment            \tSeque.match OUT     \t+   \t[match=<MatchResult 3/9: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:22]\t......................DatatypeSegment             \tOneOf.match OUT     \t+   \t[match=<MatchResult 3/9: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:21]\t.....................Expression_D_Grammar         \tOneOf.match PRN     \t    \t[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:3  MD:21]\t.....................Expression_D_Grammar         \tOneOf.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:20]\t....................Expression_D_Grammar          \tSeque.match OUT     \t    \t[match=<MatchResult 0/9: \'\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:19]\t...................Expression_D_Grammar           \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:19]\t...................Accessor_Grammar               \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts=\'ALL\']\nINFO       [PD:3  MD:19]\t...................Accessor_Grammar               \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:18]\t..................Expression_D_Grammar            \tSeque.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:17]\t.................Expression_C_Grammar             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:17]\t.................Expression_C_Grammar             \tAnyNu.match PRN     \t    \t[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts=\'ALL\']\nINFO       [PD:3  MD:17]\t.................Expression_C_Grammar             \tAnyNu.match OUT     \t    \t[match=<MatchResult 0/5: \'\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:16]\t................Expression_C_Grammar              \tSeque.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:15]\t...............Expression_C_Grammar               \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:14]\t..............Expression_A_Grammar                \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/7: \'redacted_table_name_left.id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:14]\t..............Expression_A_Grammar                \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]\nINFO       [PD:3  MD:15]\t...............Expression_A_Grammar               \tOneOf.match PRN     \t    \t[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]\nINFO       [PD:3  MD:17]\t.................Expression_A_Grammar             \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]\nINFO       [PD:3  MD:19]\t...................BinaryOperatorGrammar          \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:20]\t....................ComparisonOperatorGrammar     \tOneOf.match PRN     \t    \t[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:20]\t....................ComparisonOperatorGrammar     \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'=\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:19]\t...................BinaryOperatorGrammar          \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'=\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:18]\t..................Expression_A_Grammar            \tSeque.match OUT     \t+   \t[match=<MatchResult 1/5: \'=\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:17]\t.................Expression_A_Grammar             \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/5: \'=\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:17]\t.................Expression_C_Grammar             \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>], opts=[<Sequence: [<OneOf: [<Ref: Expression_D_Grammar>, <R..., <AnyNumberOf: [<Ref: ShorthandCastSegmen...]>]]\nINFO       [PD:3  MD:19]\t...................Expression_C_Grammar           \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]\nINFO       [PD:3  MD:21]\t.....................Expression_D_Grammar         \tOneOf.match PRN     \t    \t[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]\nINFO       [PD:3  MD:23]\t.......................FunctionSegment            \tOneOf.match PRN     \t    \t[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DatePartFunctionNameSe...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]\nINFO       [PD:3  MD:28]\t............................DatePartFunctionNameSegment\tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:26]\t..........................FunctionSegment         \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]\nINFO       [PD:3  MD:29]\t.............................FunctionNameSegment  \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:31]\t...............................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:31]\t...............................SingleIdentifierGrammar\tOneOf.match OUT     \t+   \t[match=<MatchResult 1/3: \'order_issue_category_hierarchies\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:30]\t..............................FunctionNameSegment \tSeque.match OUT     \t+   \t[match=<MatchResult 2/3: \'order_issue_cat...ry_hierarchies.\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:29]\t.............................FunctionNameSegment  \tAnyNu.match PRN     \t    \t[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:31]\t...............................SingleIdentifierGrammar\tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:31]\t...............................SingleIdentifierGrammar\tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'ancestor_id\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:30]\t..............................FunctionNameSegment \tSeque.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:29]\t.............................FunctionNameSegment  \tAnyNu.match OUT     \t+   \t[match=<MatchResult 2/3: \'order_issue_cat...ry_hierarchies.\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:29]\t.............................FunctionNameSegment  \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:29]\t.............................FunctionNameSegment  \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'ancestor_id\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:28]\t............................FunctionNameSegment   \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:26]\t..........................FunctionSegment         \tAnyNu.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:25]\t.........................FunctionSegment          \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:24]\t........................FunctionSegment           \tSeque.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:23]\t.......................FunctionSegment            \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:22]\t......................LiteralGrammar              \tOneOf.match PRN     \t    \t[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]\nINFO       [PD:3  MD:22]\t......................LiteralGrammar              \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:25]\t.........................ColumnReferenceSegment   \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:25]\t.........................ColumnReferenceSegment   \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:25]\t.........................BinaryOperatorGrammar    \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:26]\t..........................ComparisonOperatorGrammar\tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:26]\t..........................ComparisonOperatorGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:25]\t.........................BinaryOperatorGrammar    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:25]\t.........................BinaryOperatorGrammar    \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:26]\t..........................ComparisonOperatorGrammar\tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:26]\t..........................ComparisonOperatorGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:25]\t.........................BinaryOperatorGrammar    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................SingleIdentifierGrammar   \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:24]\t........................SingleIdentifierGrammar   \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_category_hierarchies\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:25]\t.........................BinaryOperatorGrammar    \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:26]\t..........................ComparisonOperatorGrammar\tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:26]\t..........................ComparisonOperatorGrammar\tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:25]\t.........................BinaryOperatorGrammar    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................ColumnReferenceSegment    \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:24]\t........................SingleIdentifierGrammar   \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:24]\t........................SingleIdentifierGrammar   \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'ancestor_id\'>, seg="\'ancestor_id\'"]\nINFO       [PD:3  MD:23]\t.......................ColumnReferenceSegment     \tDelim.match OUT     \t++  \t[match=<MatchResult 3/3: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:21]\t.....................Expression_D_Grammar         \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:20]\t....................Expression_D_Grammar          \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:19]\t...................Expression_C_Grammar           \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:18]\t..................Expression_C_Grammar            \tSeque.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:17]\t.................Expression_C_Grammar             \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'order_issue_cat...ies.ancestor_id\'>, seg="\'order_issue_category...\'"]\nINFO       [PD:3  MD:16]\t................Expression_A_Grammar              \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'= order_issue_c...ies.ancestor_id\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:15]\t...............Expression_A_Grammar               \tOneOf.match OUT     \t++  \t[match=<MatchResult 3/3: \'= order_issue_c...ies.ancestor_id\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:14]\t..............Expression_A_Grammar                \tAnyNu.match OUT     \t++  \t[match=<MatchResult 3/3: \'= order_issue_c...ies.ancestor_id\'>, seg="\'= order_issue_catego...\'"]\nINFO       [PD:3  MD:13]\t.............Expression_A_Grammar                 \tSeque.match OUT     \t++  \t[match=<MatchResult 5/5: \'redacted_table_...ies.ancestor_id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:11]\t...........JoinOnConditionSegment                 \tOptio.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_table_...ies.ancestor_id\'>, seg="\'redacted_table_name_...\'"]\nINFO       [PD:3  MD:10]\t..........JoinOnConditionSegment                  \tSeque.match OUT     \t++  \t[match=<MatchResult 5/5: \'ON redacted_tab...ies.ancestor_id\'>, seg="\'ON redacted_table_na...\'"]\nINFO       [PD:3  MD:8 ]\t........JoinClauseSegment                         \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'ON redacted_tab...ies.ancestor_id\'>, seg="\'ON redacted_table_na...\'"]\nINFO       [PD:3  MD:7 ]\t.......JoinClauseSegment                          \tSeque.match OUT     \t++  \t[match=<MatchResult 4/4: \'redacted_schema...ies.ancestor_id\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:6 ]\t......JoinClauseSegment                           \tSeque.match OUT     \t++  \t[match=<MatchResult 10/10: \'INNER JOIN reda...ies.ancestor_id\'>, seg="\'INNER JOIN redacted_...\'"]\nINFO       [PD:3  MD:4 ]\t....FromExpressionSegment                         \tAnyNu.match OUT     \t++  \t[match=<MatchResult 1/1: \'INNER JOIN reda...ies.ancestor_id\'>, seg="\'INNER JOIN redacted_...\'"]\nINFO       [PD:3  MD:3 ]\t...FromExpressionSegment                          \tSeque.match OUT     \t++  \t[match=<MatchResult 5/5: \'redacted_schema...ies.ancestor_id\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:1 ]\t.FromClauseSegment                                \tDelim.match OUT     \t++  \t[match=<MatchResult 1/1: \'redacted_schema...ies.ancestor_id\'>, seg="\'redacted_schema_name...\'"]\nINFO       [PD:3  MD:0 ]\tFromClauseSegment                                 \tSeque.match OUT     \t++  \t[match=<MatchResult 3/3: \'FROM redacted_s...ies.ancestor_id\'>, seg="\'FROM redacted_schema...\'"]\nINFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  4, P:  1]) \'FROM\'>...\nINFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  5]) \' \'>...\nINFO       [PD:4] Skipping expansion of <FromExpressionSegment: ([L:  4, P:  6])>...\nINFO       [PD:3] Skipping expansion of <NewlineSegment: ([L:  6, P: 82]) \'\\n\'>...\nINFO       \n###\n#\n# Parse Depth 3. Expanding: GroupByClauseSegment: \'GROUP BY reacted_table_name_right.descen...\'\n#\n###\nINFO       [PD:3  MD:2 ]\t..GroupByClauseSegment                            \tOneOf.match PRN     \t    \t[ns=3, ps=0, ms=0, pruned=[], opts=[<Ref: ColumnReferenceSegment>, <Ref: NumericLiteralSegment>, <Ref: ExpressionSegment>]]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:6 ]\t......ColumnReferenceSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]\nINFO       [PD:3  MD:6 ]\t......ColumnReferenceSegment                      \tSeque.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t+   \t[match=<MatchResult 1/2: \'.\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/3: \'\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/2: \'\'>, seg="\'.descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_name_right\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match PRN     \t    \t[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class \'sqlfluff.core.parser.segments.base.BracketedSegment\'>], opts=[<Ref: BinaryOperatorGrammar>]]\nINFO       [PD:3  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match PRN     \t    \t[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]\nINFO       [PD:3  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match PRN     \t    \t[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]\nINFO       [PD:3  MD:7 ]\t.......ComparisonOperatorGrammar                  \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'descendant_id\'"]\nINFO       [PD:3  MD:6 ]\t......BinaryOperatorGrammar                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....ColumnReferenceSegment                       \tOneOf.match OUT     \t    \t[match=<MatchResult 0/1: \'\'>, seg="\'descendant_id\'"]\nINFO       [PD:3  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match PRN     \t    \t[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]\nINFO       [PD:3  MD:5 ]\t.....SingleIdentifierGrammar                      \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'descendant_id\'>, seg="\'descendant_id\'"]\nINFO       [PD:3  MD:4 ]\t....ColumnReferenceSegment                        \tDelim.match OUT     \t++  \t[match=<MatchResult 3/3: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:2 ]\t..GroupByClauseSegment                            \tOneOf.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:1 ]\t.GroupByClauseSegment                             \tDelim.match OUT     \t++  \t[match=<MatchResult 1/1: \'reacted_table_n...t.descendant_id\'>, seg="\'reacted_table_name_r...\'"]\nINFO       [PD:3  MD:0 ]\tGroupByClauseSegment                              \tSeque.match OUT     \t++  \t[match=<MatchResult 7/7: \'GROUP BY reacte...t.descendant_id\'>, seg="\'GROUP BY reacted_tab...\'"]\nINFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  7, P:  1]) \'GROUP\'>...\nINFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  7, P:  6]) \' \'>...\nINFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  7, P:  7]) \'BY\'>...\nINFO       [PD:4] Skipping expansion of <Indent: ([L:  7, P:  9]) \'\'>...\nINFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  7, P:  9]) \' \'>...\nINFO       [PD:4] Skipping expansion of <ColumnReferenceSegment: ([L:  7, P: 10])>...\nINFO       [PD:4] Skipping expansion of <Dedent: ([L:  7, P: 48]) \'\'>...\nINFO       [PD:1] Skipping expansion of <NewlineSegment: ([L:  7, P: 48]) \'\\n\'>...\nINFO       \n###\n#\n# Parsed Tree:\n#\n###\nINFO       \n[L:  1, P:  1]      |file:\n[L:  1, P:  1]      |    statement:\n[L:  1, P:  1]      |        select_statement:\n[L:  1, P:  1]      |            select_clause:\n[L:  1, P:  1]      |                keyword:                                      \'SELECT\'\n[L:  1, P:  7]      |                [META] indent:\n[L:  1, P:  7]      |                newline:                                      \'\\n\'\n[L:  2, P:  1]      |                whitespace:                                   \'    \'\n[L:  2, P:  5]      |                select_clause_element:\n[L:  2, P:  5]      |                    column_reference:\n[L:  2, P:  5]      |                        identifier:                           \'reacted_table_name_right\'\n[L:  2, P: 29]      |                        dot:                                  \'.\'\n[L:  2, P: 30]      |                        identifier:                           \'descendant_id\'\n[L:  2, P: 43]      |                    whitespace:                               \' \'\n[L:  2, P: 44]      |                    alias_expression:\n[L:  2, P: 44]      |                        keyword:                              \'AS\'\n[L:  2, P: 46]      |                        whitespace:                           \' \'\n[L:  2, P: 47]      |                        identifier:                           \'category_id\'\n[L:  2, P: 58]      |                comma:                                        \',\'\n[L:  2, P: 59]      |                newline:                                      \'\\n\'\n[L:  3, P:  1]      |                whitespace:                                   \'    \'\n[L:  3, P:  5]      |                select_clause_element:\n[L:  3, P:  5]      |                    function:\n[L:  3, P:  5]      |                        function_name:\n[L:  3, P:  5]      |                            function_name_identifier:         \'string_agg\'\n[L:  3, P: 15]      |                        bracketed:\n[L:  3, P: 15]      |                            start_bracket:                    \'(\'\n[L:  3, P: 16]      |                            [META] indent:\n[L:  3, P: 16]      |                            expression:\n[L:  3, P: 16]      |                                column_reference:\n[L:  3, P: 16]      |                                    identifier:               \'redacted_table_name_left\'\n[L:  3, P: 40]      |                                    dot:                      \'.\'\n[L:  3, P: 41]      |                                    identifier:               \'name\'\n[L:  3, P: 45]      |                            comma:                            \',\'\n[L:  3, P: 46]      |                            whitespace:                       \' \'\n[L:  3, P: 47]      |                            expression:\n[L:  3, P: 47]      |                                literal:                      "\' Ã¢â€ â€™ \'"\n[L:  3, P: 54]      |                            whitespace:                       \' \'\n[L:  3, P: 55]      |                            orderby_clause:\n[L:  3, P: 55]      |                                keyword:                      \'ORDER\'\n[L:  3, P: 60]      |                                whitespace:                   \' \'\n[L:  3, P: 61]      |                                keyword:                      \'BY\'\n[L:  3, P: 63]      |                                [META] indent:\n[L:  3, P: 63]      |                                whitespace:                   \' \'\n[L:  3, P: 64]      |                                column_reference:\n[L:  3, P: 64]      |                                    identifier:               \'reacted_table_name_right\'\n[L:  3, P: 88]      |                                    dot:                      \'.\'\n[L:  3, P: 89]      |                                    identifier:               \'generations\'\n[L:  3, P:100]      |                                whitespace:                   \' \'\n[L:  3, P:101]      |                                keyword:                      \'DESC\'\n[L:  3, P:105]      |                                [META] dedent:\n[L:  3, P:105]      |                            [META] dedent:\n[L:  3, P:105]      |                            end_bracket:                      \')\'\n[L:  3, P:106]      |                    whitespace:                               \' \'\n[L:  3, P:107]      |                    alias_expression:\n[L:  3, P:107]      |                        keyword:                              \'AS\'\n[L:  3, P:109]      |                        whitespace:                           \' \'\n[L:  3, P:110]      |                        identifier:                           \'breadcrumbs\'\n[L:  3, P:121]      |            whitespace:                                       \' \'\n[L:  3, P:122]      |            comment:                                          \'-- noqa\'\n[L:  3, P:129]      |            newline:                                          \'\\n\'\n[L:  4, P:  1]      |            [META] dedent:\n[L:  4, P:  1]      |            from_clause:\n[L:  4, P:  1]      |                keyword:                                      \'FROM\'\n[L:  4, P:  5]      |                whitespace:                                   \' \'\n[L:  4, P:  6]      |                from_expression:\n[L:  4, P:  6]      |                    [META] indent:\n[L:  4, P:  6]      |                    from_expression_element:\n[L:  4, P:  6]      |                        table_expression:\n[L:  4, P:  6]      |                            table_reference:\n[L:  4, P:  6]      |                                identifier:                   \'redacted_schema_name_redacted_table_name_left\'\n[L:  4, P: 68]      |                        whitespace:                           \' \'\n[L:  4, P: 69]      |                        alias_expression:\n[L:  4, P: 69]      |                            keyword:                          \'AS\'\n[L:  4, P: 71]      |                            whitespace:                       \' \'\n[L:  4, P: 72]      |                            identifier:                       \'redacted_table_name_left\'\n[L:  4, P: 96]      |                    newline:                                  \'\\n\'\n[L:  5, P:  1]      |                    [META] dedent:\n[L:  5, P:  1]      |                    join_clause:\n[L:  5, P:  1]      |                        keyword:                              \'INNER\'\n[L:  5, P:  6]      |                        whitespace:                           \' \'\n[L:  5, P:  7]      |                        keyword:                              \'JOIN\'\n[L:  5, P: 11]      |                        [META] indent:\n[L:  5, P: 11]      |                        whitespace:                           \' \'\n[L:  5, P: 12]      |                        from_expression_element:\n[L:  5, P: 12]      |                            table_expression:\n[L:  5, P: 12]      |                                table_reference:\n[L:  5, P: 12]      |                                    identifier:               \'redacted_schema_name_reacted_table_name_right\'\n[L:  5, P: 74]      |                            whitespace:                       \' \'\n[L:  5, P: 75]      |                            alias_expression:\n[L:  5, P: 75]      |                                keyword:                      \'AS\'\n[L:  5, P: 77]      |                                whitespace:                   \' \'\n[L:  5, P: 78]      |                                identifier:                   \'reacted_table_name_right\'\n[L:  5, P:102]      |                        newline:                              \'\\n\'\n[L:  6, P:  1]      |                        whitespace:                           \'    \'\n[L:  6, P:  5]      |                        join_on_condition:\n[L:  6, P:  5]      |                            keyword:                          \'ON\'\n[L:  6, P:  7]      |                            [META] indent:\n[L:  6, P:  7]      |                            whitespace:                       \' \'\n[L:  6, P:  8]      |                            expression:\n[L:  6, P:  8]      |                                column_reference:\n[L:  6, P:  8]      |                                    identifier:               \'redacted_table_name_left\'\n[L:  6, P: 32]      |                                    dot:                      \'.\'\n[L:  6, P: 33]      |                                    identifier:               \'id\'\n[L:  6, P: 35]      |                                whitespace:                   \' \'\n[L:  6, P: 36]      |                                comparison_operator:          \'=\'\n[L:  6, P: 37]      |                                whitespace:                   \' \'\n[L:  6, P: 38]      |                                column_reference:\n[L:  6, P: 38]      |                                    identifier:               \'order_issue_category_hierarchies\'\n[L:  6, P: 70]      |                                    dot:                      \'.\'\n[L:  6, P: 71]      |                                    identifier:               \'ancestor_id\'\n[L:  6, P: 82]      |                            [META] dedent:\n[L:  6, P: 82]      |                        [META] dedent:\n[L:  6, P: 82]      |            newline:                                          \'\\n\'\n[L:  7, P:  1]      |            groupby_clause:\n[L:  7, P:  1]      |                keyword:                                      \'GROUP\'\n[L:  7, P:  6]      |                whitespace:                                   \' \'\n[L:  7, P:  7]      |                keyword:                                      \'BY\'\n[L:  7, P:  9]      |                [META] indent:\n[L:  7, P:  9]      |                whitespace:                                   \' \'\n[L:  7, P: 10]      |                column_reference:\n[L:  7, P: 10]      |                    identifier:                               \'reacted_table_name_right\'\n[L:  7, P: 34]      |                    dot:                                      \'.\'\n[L:  7, P: 35]      |                    identifier:                               \'descendant_id\'\n[L:  7, P: 48]      |                [META] dedent:\n[L:  7, P: 48]      |    newline:                                                  \'\\n\'\n\nINFO       LINTING (reproduce.sql)\n== [reproduce.sql] LINTING\nINFO       Parsed noqa directives from file: [NoQaDirective(line_no=3, rules=None, action=None)]\nDEBUG      [L003] Evaluating line #1. {\'line_no\': 1, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003] Evaluating line #2. {\'line_no\': 2, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #1\nDEBUG      [L003]     Comparison Line: {\'line_no\': 1, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #1\nDEBUG      [L003] Evaluating line #3. {\'line_no\': 3, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #2\nDEBUG      [L003]     Indent deemed ok comparing to #2\nDEBUG      [L003] Evaluating line #4. {\'line_no\': 4, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #1\nDEBUG      [L003]     Indent deemed ok comparing to #1\nDEBUG      [L003] Evaluating line #5. {\'line_no\': 5, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #4\nDEBUG      [L003]     Indent deemed ok comparing to #4\nDEBUG      [L003] Evaluating line #6. {\'line_no\': 6, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [deeper indent balance] Comparing to #5\nDEBUG      [L003]     Comparison Line: {\'line_no\': 5, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': 11, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #5\nDEBUG      [L003] Evaluating line #7. {\'line_no\': 7, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #5\nDEBUG      [L003]     Indent deemed ok comparing to #5\nDEBUG      [L006] Found Target [main] @[L:  6, P: 36]: \'=\'\nDEBUG      [L010] Selected \'capitalisation_policy\': \'consistent\' from options [\'upper\', \'lower\', \'capitalise\']\nDEBUG      [L010] Refuted cases after segment \'SELECT\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'SELECT\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'ORDER\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'ORDER\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'BY\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'BY\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'DESC\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'DESC\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'FROM\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'FROM\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'INNER\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'INNER\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'JOIN\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'JOIN\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'ON\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'ON\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'GROUP\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'GROUP\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'BY\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'BY\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L014] Selected \'extended_capitalisation_policy\': \'consistent\' from options [\'upper\', \'lower\', \'pascal\', \'capitalise\']\nDEBUG      [L014] Refuted cases after segment \'reacted_table_name_right\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'reacted_table_name_right\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'descendant_id\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'descendant_id\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'category_id\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'category_id\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'redacted_table_name_left\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_table_name_left\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'name\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'name\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'reacted_table_name_right\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'reacted_table_name_right\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'generations\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'generations\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'breadcrumbs\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'breadcrumbs\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'redacted_schema_name_redacted_table_name_left\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_schema_name_redacted_table_name_left\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'redacted_table_name_left\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_table_name_left\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'redacted_schema_name_reacted_table_name_right\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_schema_name_reacted_table_name_right\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'reacted_table_name_right\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'reacted_table_name_right\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'redacted_table_name_left\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_table_name_left\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'id\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'id\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'order_issue_category_hierarchies\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'order_issue_category_hierarchies\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'ancestor_id\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'ancestor_id\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'reacted_table_name_right\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'reacted_table_name_right\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L014] Refuted cases after segment \'descendant_id\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'descendant_id\': [\'lower\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nINFO       [L016] Attempting move of inline comment at end of line: <CommentSegment: ([L:  3, P:122]) \'-- noqa\'>\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nINFO       0 -> "SELECT\\n    reacted_table_name_right.descendant_id AS category_id,\\n    string_agg(redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\\nFROM "\nINFO       0 -> "{{ ref2(\'redacted_schema_name\', \'redacted_table_name_left\') }}"\nINFO       0 -> \' AS redacted_table_name_left\\nINNER JOIN \'\nINFO       0 -> "{{ ref2(\'redacted_schema_name\', \'reacted_table_name_right\') }}"\nINFO       0 -> \' AS reacted_table_name_right\\n    ON redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\\nGROUP BY reacted_table_name_right.descendant_id\\n\'\nINFO       [L016] Sections:\nINFO       [L016]     0: <Section @ [L:  4, P:  1]: content [0:0]. \'FROM\'>\nINFO       [L016]     1: <Section @ [L:  4, P:  5]: breakpoint [0:1]. \' \'>\nINFO       [L016]     2: <Section @ [L:  4, P:  6]: content [1:0]. \'redacted_schema_name_redacted_table_name_left AS redacted_table_name_left\'>\nINFO       [L016] Split at: [(<Section @ [L:  4, P:  5]: breakpoint [0:1]. \' \'>, 1)]\nINFO       [L016] Fixes: [<LintFix: delete @[L:  4, P:  5] delete:\' \'>, <LintFix: create @[L:  4, P:  6] create:\'\\n    \'>]\nDEBUG      [L016] !! Violation Found: \'Line is too long\'\nDEBUG      [L016] !! Fix Proposed: <LintFix: delete @[L:  4, P:  5] delete:\' \'>\nDEBUG      [L016] !! Fix Proposed: <LintFix: create @[L:  4, P:  6] create:\'\\n    \'>\nINFO       [L016] Sections:\nINFO       [L016]     0: <Section @ [L:  5, P:  1]: content [0:0]. \'INNER JOIN\'>\nINFO       [L016]     1: <Section @ [L:  5, P: 11]: breakpoint [0:1]. \' \'>\nINFO       [L016]     2: <Section @ [L:  5, P: 12]: content [1:0]. \'redacted_schema_name_reacted_table_name_right AS reacted_table_name_right\'>\nINFO       [L016] Split at: [(<Section @ [L:  5, P: 11]: breakpoint [0:1]. \' \'>, 1)]\nINFO       [L016] Fixes: [<LintFix: delete @[L:  5, P: 11] delete:\' \'>, <LintFix: create @[L:  5, P: 12] create:\'\\n    \'>]\nDEBUG      [L016] !! Violation Found: \'Line is too long\'\nDEBUG      [L016] !! Fix Proposed: <LintFix: delete @[L:  5, P: 11] delete:\' \'>\nDEBUG      [L016] !! Fix Proposed: <LintFix: create @[L:  5, P: 12] create:\'\\n    \'>\nINFO       [L016] Sections:\nINFO       [L016]     0: <Section @ [L:  6, P:  5]: content [0:0]. \'ON\'>\nINFO       [L016]     1: <Section @ [L:  6, P:  7]: breakpoint [0:1]. \' \'>\nINFO       [L016]     2: <Section @ [L:  6, P:  8]: content [1:0]. \'redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\'>\nINFO       [L016] Split at: [(<Section @ [L:  6, P:  7]: breakpoint [0:1]. \' \'>, 1)]\nINFO       [L016] Fixes: [<LintFix: delete @[L:  6, P:  7] delete:\' \'>, <LintFix: create @[L:  6, P:  8] create:\'\\n        \'>]\nDEBUG      [L016] !! Violation Found: \'Line is too long\'\nDEBUG      [L016] !! Fix Proposed: <LintFix: delete @[L:  6, P:  7] delete:\' \'>\nDEBUG      [L016] !! Fix Proposed: <LintFix: create @[L:  6, P:  8] create:\'\\n        \'>\nINFO       Applying Fixes [L016]: [<LintFix: delete @[L:  4, P:  5] delete:\' \'>, <LintFix: create @[L:  4, P:  6] create:\'\\n    \'>, <LintFix: delete @[L:  5, P: 11] delete:\' \'>, <LintFix: create @[L:  5, P: 12] create:\'\\n    \'>, <LintFix: delete @[L:  6, P:  7] delete:\' \'>, <LintFix: create @[L:  6, P:  8] create:\'\\n        \'>]\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  4, P:  5] delete:\' \'> -> <WhitespaceSegment: ([L:  4, P:  5]) \' \'>\nDEBUG      Matched fix against segment: <LintFix: create @[L:  4, P:  6] create:\'\\n    \'> -> <CodeSegment: ([L:  4, P:  6]) \'redacted_schema_name_redacted_table_name_left\'>\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  5, P: 11] delete:\' \'> -> <WhitespaceSegment: ([L:  5, P: 11]) \' \'>\nDEBUG      Matched fix against segment: <LintFix: create @[L:  5, P: 12] create:\'\\n    \'> -> <CodeSegment: ([L:  5, P: 12]) \'redacted_schema_name_reacted_table_name_right\'>\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  6, P:  7] delete:\' \'> -> <WhitespaceSegment: ([L:  6, P:  7]) \' \'>\nDEBUG      Matched fix against segment: <LintFix: create @[L:  6, P:  8] create:\'\\n        \'> -> <CodeSegment: ([L:  6, P:  8]) \'redacted_table_name_left\'>\nDEBUG      [L026] !! Violation Found: "Reference \'order_issue_category_hierarchies.ancestor_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L030] Selected \'capitalisation_policy\': \'consistent\' from options [\'upper\', \'lower\', \'capitalise\']\nDEBUG      [L030] Refuted cases after segment \'string_agg\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L030] Possible cases after segment \'string_agg\': [\'lower\']\nDEBUG      [L030] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L031] !! Violation Found: \'Avoid aliases in from clauses and join conditions.\'\nDEBUG      [L031] !! Violation Found: \'Avoid aliases in from clauses and join conditions.\'\nDEBUG      [L031] !! Fix Proposed: <LintFix: delete @[L:  4, P: 69] delete:\'AS redacted_table_name_left\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: delete @[L:  4, P: 68] delete:\' \'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  4, P: 72] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  3, P: 16] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  6, P:  8] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: delete @[L:  5, P: 75] delete:\'AS reacted_table_name_right\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: delete @[L:  5, P: 74] delete:\' \'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  5, P: 78] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  2, P:  5] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  3, P: 64] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>\nDEBUG      [L031] !! Fix Proposed: <LintFix: edit @[L:  7, P: 10] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>\nINFO       Applying Fixes [L031]: [<LintFix: delete @[L:  4, P: 69] delete:\'AS redacted_table_name_left\'>, <LintFix: delete @[L:  4, P: 68] delete:\' \'>, <LintFix: edit @[L:  4, P: 72] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'>, <LintFix: edit @[L:  3, P: 16] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'>, <LintFix: edit @[L:  6, P:  8] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'>, <LintFix: delete @[L:  5, P: 75] delete:\'AS reacted_table_name_right\'>, <LintFix: delete @[L:  5, P: 74] delete:\' \'>, <LintFix: edit @[L:  5, P: 78] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>, <LintFix: edit @[L:  2, P:  5] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>, <LintFix: edit @[L:  3, P: 64] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>, <LintFix: edit @[L:  7, P: 10] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'>]\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  2, P:  5] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'> -> <CodeSegment: ([L:  2, P:  5]) \'reacted_table_name_right\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  3, P: 16] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'> -> <CodeSegment: ([L:  3, P: 16]) \'redacted_table_name_left\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  3, P: 64] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'> -> <CodeSegment: ([L:  3, P: 64]) \'reacted_table_name_right\'>\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  4, P: 68] delete:\' \'> -> <WhitespaceSegment: ([L:  4, P: 68]) \' \'>\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  4, P: 69] delete:\'AS redacted_table_name_left\'> -> <AliasExpressionSegment: ([L:  4, P: 69])>\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  5, P: 74] delete:\' \'> -> <WhitespaceSegment: ([L:  5, P: 74]) \' \'>\nDEBUG      Matched fix against segment: <LintFix: delete @[L:  5, P: 75] delete:\'AS reacted_table_name_right\'> -> <AliasExpressionSegment: ([L:  5, P: 75])>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  6, P:  8] edt:\'redacted_table_name_left\'->\'\\n    redacted_schema_name_redacted_table_name_left\'> -> <CodeSegment: ([L:  6, P:  8]) \'redacted_table_name_left\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  7, P: 10] edt:\'reacted_table_name_right\'->\'\\n    redacted_schema_name_reacted_table_name_right\'> -> <CodeSegment: ([L:  7, P: 10]) \'reacted_table_name_right\'>\nDEBUG      [L044] Analyzing query: SELECT\n    \n    redacted_schema_name_reacted_table_name_right.descendant_id AS category_id,\n    string_agg(\n    redacted_schema_name_redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY \n    redacted_schema_name_reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\nFROM\n    redacted_schema_name_redacted_table_name_left\nINNER JOIN\n    redacted_schema_name_reacted_table_name_right\n    ON\n        \n    redacted_schema_name_redacted_table_name_left.id = order_issue_category_hierarchies.ancestor_id\nGROUP BY \n    redacted_schema_name_reacted_table_name_right.descendant_id\nDEBUG      [L049] Found equals/not equals @[L:  6, P: 36]: \'=\'\nDEBUG      [L003] Evaluating line #1. {\'line_no\': 1, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003] Evaluating line #2. {\'line_no\': 2, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #1\nDEBUG      [L003]     Comparison Line: {\'line_no\': 1, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #1\nDEBUG      [L003] Evaluating line #3. {\'line_no\': 3, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #2\nDEBUG      [L003]     Indent deemed ok comparing to #2\nDEBUG      [L003] Evaluating line #4. {\'line_no\': 4, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #1\nDEBUG      [L003]     Indent deemed ok comparing to #1\nDEBUG      [L003] Evaluating line #5. {\'line_no\': 5, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #4\nDEBUG      [L003]     Comparison Line: {\'line_no\': 4, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #4\nDEBUG      [L003] Evaluating line #6. {\'line_no\': 6, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #4\nDEBUG      [L003]     Indent deemed ok comparing to #4\nDEBUG      [L003] Evaluating line #7. {\'line_no\': 7, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #6\nDEBUG      [L003]     Comparison Line: {\'line_no\': 6, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #6\nDEBUG      [L003] Evaluating line #8. {\'line_no\': 8, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #7\nDEBUG      [L003]     Indent deemed ok comparing to #7\nDEBUG      [L003] Evaluating line #9. {\'line_no\': 9, \'indent_size\': 8, \'indent_balance\': 2, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #8\nDEBUG      [L003]     Comparison Line: {\'line_no\': 8, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #8\nDEBUG      [L003] Evaluating line #10. {\'line_no\': 10, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #6\nDEBUG      [L003]     Indent deemed ok comparing to #6\nDEBUG      [L006] Found Target [main] @[L:  6, P: 36]: \'=\'\nDEBUG      [L010] Refuted cases after segment \'SELECT\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'SELECT\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'ORDER\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'ORDER\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'BY\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'BY\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'DESC\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'DESC\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'FROM\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'FROM\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'INNER\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'INNER\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'JOIN\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'JOIN\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'ON\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'ON\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'GROUP\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'GROUP\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'BY\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'BY\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': [\'capitalise\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'pascal\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'descendant_id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'descendant_id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'descendant_id\', fixing to \'Descendant_id\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  2, P: 30] edt:\'descendant_id\'->\'Descendant_id\'>\nDEBUG      [L014] Refuted cases after segment \'category_id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'category_id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'category_id\', fixing to \'Category_id\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  2, P: 47] edt:\'category_id\'->\'Category_id\'>\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_redacted_table_name_left\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'name\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'name\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'name\', fixing to \'Name\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_reacted_table_name_right\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'generations\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'generations\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'generations\', fixing to \'Generations\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] Refuted cases after segment \'breadcrumbs\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'breadcrumbs\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'breadcrumbs\', fixing to \'Breadcrumbs\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] Refuted cases after segment \'redacted_schema_name_redacted_table_name_left\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_schema_name_redacted_table_name_left\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'redacted_schema_name_redacted_table_name_left\', fixing to \'Redacted_schema_name_redacted_table_name_left\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  4, P:  6] edt:\'redacted_schema_name_redacted_table_name_left\'->\'Redacted_schema_name_redacted_table_name_left\'>\nDEBUG      [L014] Refuted cases after segment \'redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'redacted_schema_name_reacted_table_name_right\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'redacted_schema_name_reacted_table_name_right\', fixing to \'Redacted_schema_name_reacted_table_name_right\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  5, P: 12] edt:\'redacted_schema_name_reacted_table_name_right\'->\'Redacted_schema_name_reacted_table_name_right\'>\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_redacted_table_name_left\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'id\', fixing to \'Id\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  6, P: 33] edt:\'id\'->\'Id\'>\nDEBUG      [L014] Refuted cases after segment \'order_issue_category_hierarchies\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'order_issue_category_hierarchies\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'order_issue_category_hierarchies\', fixing to \'Order_issue_category_hierarchies\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  6, P: 38] edt:\'order_issue_category_hierarchies\'->\'Order_issue_category_hierarchies\'>\nDEBUG      [L014] Refuted cases after segment \'ancestor_id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'ancestor_id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'ancestor_id\', fixing to \'Ancestor_id\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  6, P: 71] edt:\'ancestor_id\'->\'Ancestor_id\'>\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_reacted_table_name_right\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'descendant_id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'descendant_id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'descendant_id\', fixing to \'Descendant_id\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] !! Violation Found: \'Unquoted identifiers must be consistently capitalised.\'\nDEBUG      [L014] !! Fix Proposed: <LintFix: edit @[L:  7, P: 35] edt:\'descendant_id\'->\'Descendant_id\'>\nINFO       Applying Fixes [L014]: [<LintFix: edit @[L:  2, P: 30] edt:\'descendant_id\'->\'Descendant_id\'>, <LintFix: edit @[L:  2, P: 47] edt:\'category_id\'->\'Category_id\'>, <LintFix: edit @[L:  4, P:  6] edt:\'redacted_schema_name_redacted_table_name_left\'->\'Redacted_schema_name_redacted_table_name_left\'>, <LintFix: edit @[L:  5, P: 12] edt:\'redacted_schema_name_reacted_table_name_right\'->\'Redacted_schema_name_reacted_table_name_right\'>, <LintFix: edit @[L:  6, P: 33] edt:\'id\'->\'Id\'>, <LintFix: edit @[L:  6, P: 38] edt:\'order_issue_category_hierarchies\'->\'Order_issue_category_hierarchies\'>, <LintFix: edit @[L:  6, P: 71] edt:\'ancestor_id\'->\'Ancestor_id\'>, <LintFix: edit @[L:  7, P: 35] edt:\'descendant_id\'->\'Descendant_id\'>]\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  2, P: 30] edt:\'descendant_id\'->\'Descendant_id\'> -> <CodeSegment: ([L:  2, P: 30]) \'descendant_id\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  2, P: 47] edt:\'category_id\'->\'Category_id\'> -> <CodeSegment: ([L:  2, P: 47]) \'category_id\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  4, P:  6] edt:\'redacted_schema_name_redacted_table_name_left\'->\'Redacted_schema_name_redacted_table_name_left\'> -> <CodeSegment: ([L:  4, P:  6]) \'redacted_schema_name_redacted_table_name_left\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  5, P: 12] edt:\'redacted_schema_name_reacted_table_name_right\'->\'Redacted_schema_name_reacted_table_name_right\'> -> <CodeSegment: ([L:  5, P: 12]) \'redacted_schema_name_reacted_table_name_right\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  6, P: 33] edt:\'id\'->\'Id\'> -> <CodeSegment: ([L:  6, P: 33]) \'id\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  6, P: 38] edt:\'order_issue_category_hierarchies\'->\'Order_issue_category_hierarchies\'> -> <CodeSegment: ([L:  6, P: 38]) \'order_issue_category_hierarchies\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  6, P: 71] edt:\'ancestor_id\'->\'Ancestor_id\'> -> <CodeSegment: ([L:  6, P: 71]) \'ancestor_id\'>\nDEBUG      Matched fix against segment: <LintFix: edit @[L:  7, P: 35] edt:\'descendant_id\'->\'Descendant_id\'> -> <CodeSegment: ([L:  7, P: 35]) \'descendant_id\'>\nINFO       [L016] Sections:\nINFO       [L016]     0: <Section @ [L:  2, P:  5]: content [0:0]. \'\\n    redacted_schema_name_reacted_table_name_right.Descendant_id AS Category_id\'>\nINFO       [L016]     1: <Section @ [L:  2, P: 58]: pausepoint [0:0]. \',\'>\nDEBUG      [L016] !! Violation Found: \'Line is too long\'\nINFO       [L016] Attempting move of inline comment at end of line: <CommentSegment: ([L:  3, P:122]) \'-- noqa\'>\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L026] !! Violation Found: "Reference \'\\\\n    redacted_schema_name_reacted_table_name_right.Descendant_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L026] !! Violation Found: "Reference \'\\\\n    redacted_schema_name_reacted_table_name_right.Descendant_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L026] !! Violation Found: "Reference \'\\\\n        \\\\n    redacted_schema_name_redacted_table_name_left.Id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L026] !! Violation Found: "Reference \'Order_issue_category_hierarchies.Ancestor_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L030] Refuted cases after segment \'string_agg\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L030] Possible cases after segment \'string_agg\': [\'lower\']\nDEBUG      [L030] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L044] Analyzing query: SELECT\n    \n    redacted_schema_name_reacted_table_name_right.Descendant_id AS Category_id,\n    string_agg(\n    redacted_schema_name_redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY \n    redacted_schema_name_reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\nFROM\n    Redacted_schema_name_redacted_table_name_left\nINNER JOIN\n    Redacted_schema_name_reacted_table_name_right\n    ON\n        \n    redacted_schema_name_redacted_table_name_left.Id = Order_issue_category_hierarchies.Ancestor_id\nGROUP BY \n    redacted_schema_name_reacted_table_name_right.Descendant_id\nDEBUG      [L049] Found equals/not equals @[L:  6, P: 36]: \'=\'\nDEBUG      [L003] Evaluating line #1. {\'line_no\': 1, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003] Evaluating line #2. {\'line_no\': 2, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #1\nDEBUG      [L003]     Comparison Line: {\'line_no\': 1, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #1\nDEBUG      [L003] Evaluating line #3. {\'line_no\': 3, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #2\nDEBUG      [L003]     Indent deemed ok comparing to #2\nDEBUG      [L003] Evaluating line #4. {\'line_no\': 4, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #1\nDEBUG      [L003]     Indent deemed ok comparing to #1\nDEBUG      [L003] Evaluating line #5. {\'line_no\': 5, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #4\nDEBUG      [L003]     Comparison Line: {\'line_no\': 4, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #4\nDEBUG      [L003] Evaluating line #6. {\'line_no\': 6, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #4\nDEBUG      [L003]     Indent deemed ok comparing to #4\nDEBUG      [L003] Evaluating line #7. {\'line_no\': 7, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #6\nDEBUG      [L003]     Comparison Line: {\'line_no\': 6, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #6\nDEBUG      [L003] Evaluating line #8. {\'line_no\': 8, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #7\nDEBUG      [L003]     Indent deemed ok comparing to #7\nDEBUG      [L003] Evaluating line #9. {\'line_no\': 9, \'indent_size\': 8, \'indent_balance\': 2, \'hanging_indent\': None, \'clean_indent\': True}\nDEBUG      [L003]     [deeper indent balance] Comparing to #8\nDEBUG      [L003]     Comparison Line: {\'line_no\': 8, \'indent_size\': 4, \'indent_balance\': 1, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     Indent deemed ok comparing to #8\nDEBUG      [L003] Evaluating line #10. {\'line_no\': 10, \'indent_size\': 0, \'indent_balance\': 0, \'hanging_indent\': None, \'clean_indent\': False}\nDEBUG      [L003]     [same indent balance] Comparing to #6\nDEBUG      [L003]     Indent deemed ok comparing to #6\nDEBUG      [L006] Found Target [main] @[L:  6, P: 36]: \'=\'\nDEBUG      [L010] Refuted cases after segment \'SELECT\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'SELECT\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'ORDER\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'ORDER\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'BY\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'BY\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'DESC\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'DESC\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'AS\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'AS\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'FROM\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'FROM\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'INNER\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'INNER\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'JOIN\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'JOIN\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'ON\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'ON\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'GROUP\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'GROUP\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L010] Refuted cases after segment \'BY\': {\'capitalise\', \'lower\'}\nDEBUG      [L010] Possible cases after segment \'BY\': [\'upper\']\nDEBUG      [L010] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'lower\'}, \'latest_possible_case\': \'upper\'}\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': [\'capitalise\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'pascal\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Descendant_id\': {\'pascal\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Descendant_id\': [\'capitalise\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'pascal\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Category_id\': {\'pascal\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Category_id\': [\'capitalise\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'pascal\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': {\'pascal\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': [\'capitalise\']\nDEBUG      [L014] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'pascal\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'name\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'name\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'name\', fixing to \'Name\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_reacted_table_name_right\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'generations\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'generations\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'generations\', fixing to \'Generations\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] Refuted cases after segment \'breadcrumbs\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'breadcrumbs\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] INCONSISTENT Capitalisation of segment \'breadcrumbs\', fixing to \'Breadcrumbs\' and returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L014] Refuted cases after segment \'Redacted_schema_name_redacted_table_name_left\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Redacted_schema_name_redacted_table_name_left\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'Redacted_schema_name_redacted_table_name_left\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Redacted_schema_name_reacted_table_name_right\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'Redacted_schema_name_reacted_table_name_right\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_redacted_table_name_left\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_redacted_table_name_left\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'Id\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Order_issue_category_hierarchies\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Order_issue_category_hierarchies\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'Order_issue_category_hierarchies\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Ancestor_id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Ancestor_id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'Ancestor_id\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'\n    redacted_schema_name_reacted_table_name_right\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'\n    redacted_schema_name_reacted_table_name_right\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nDEBUG      [L014] Refuted cases after segment \'Descendant_id\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}\nDEBUG      [L014] Possible cases after segment \'Descendant_id\': []\nDEBUG      [L014] Getting concrete policy \'capitalise\' from memory\nDEBUG      [L014] Capitalisation of segment \'Descendant_id\' already OK with policy \'capitalise\', returning with memory {\'refuted_cases\': {\'pascal\', \'capitalise\', \'lower\', \'upper\'}, \'latest_possible_case\': \'capitalise\'}\nINFO       [L016] Sections:\nINFO       [L016]     0: <Section @ [L:  2, P:  5]: content [0:0]. \'\\n    redacted_schema_name_reacted_table_name_right.Descendant_id AS Category_id\'>\nINFO       [L016]     1: <Section @ [L:  2, P: 58]: pausepoint [0:0]. \',\'>\nDEBUG      [L016] !! Violation Found: \'Line is too long\'\nINFO       [L016] Attempting move of inline comment at end of line: <CommentSegment: ([L:  3, P:122]) \'-- noqa\'>\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      Developer Note: Edit segment found with preset position marker. These should be unset and calculated later.\nDEBUG      [L026] !! Violation Found: "Reference \'\\\\n    redacted_schema_name_reacted_table_name_right.Descendant_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L026] !! Violation Found: "Reference \'\\\\n    redacted_schema_name_reacted_table_name_right.Descendant_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L026] !! Violation Found: "Reference \'\\\\n        \\\\n    redacted_schema_name_redacted_table_name_left.Id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L026] !! Violation Found: "Reference \'Order_issue_category_hierarchies.Ancestor_id\' refers to table/view not found in the FROM clause or found in parent subquery."\nDEBUG      [L030] Refuted cases after segment \'string_agg\': {\'capitalise\', \'pascal\', \'upper\'}\nDEBUG      [L030] Possible cases after segment \'string_agg\': [\'lower\']\nDEBUG      [L030] Consistent capitalization, returning with memory: {\'refuted_cases\': {\'capitalise\', \'pascal\', \'upper\'}, \'latest_possible_case\': \'lower\'}\nDEBUG      [L044] Analyzing query: SELECT\n    \n    redacted_schema_name_reacted_table_name_right.Descendant_id AS Category_id,\n    string_agg(\n    redacted_schema_name_redacted_table_name_left.name, \' Ã¢â€ â€™ \' ORDER BY \n    redacted_schema_name_reacted_table_name_right.generations DESC) AS breadcrumbs -- noqa\nFROM\n    Redacted_schema_name_redacted_table_name_left\nINNER JOIN\n    Redacted_schema_name_reacted_table_name_right\n    ON\n        \n    redacted_schema_name_redacted_table_name_left.Id = Order_issue_category_hierarchies.Ancestor_id\nGROUP BY \n    redacted_schema_name_reacted_table_name_right.Descendant_id\nDEBUG      [L049] Found equals/not equals @[L:  6, P: 36]: \'=\'\nINFO       Fix loop complete. Stability achieved after 2/10 loops.\n== [reproduce.sql] FAIL\nL:   4 | P:  72 | L031 | Avoid aliases in from clauses and join conditions.\nL:   4 | P:  96 | L016 | Line is too long\nL:   5 | P:  78 | L031 | Avoid aliases in from clauses and join conditions.\nL:   5 | P: 102 | L016 | Line is too long\nL:   6 | P:  82 | L016 | Line is too long\n==== fixing violations ====\n5 fixable linting violations found\nAre you sure you wish to attempt to fix these? [Y/n] Traceback (most recent call last):\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/bin/sqlfluff", line 33, in <module>\n    sys.exit(load_entry_point(\'sqlfluff\', \'console_scripts\', \'sqlfluff\')())\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/core.py", line 1157, in __call__\n    return self.main(*args, **kwargs)\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/core.py", line 1078, in main\n    rv = self.invoke(ctx)\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/core.py", line 1688, in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/core.py", line 1434, in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/core.py", line 783, in invoke\n    return __callback(*args, **kwargs)\n  File "/sqlfluff__sqlfluff/src/sqlfluff/cli/commands.py", line 590, in fix\n    c = click.getchar().lower()\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/termui.py", line 744, in getchar\n    return _getchar(echo)\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/_termui_impl.py", line 732, in getchar\n    with raw_terminal() as fd:\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/contextlib.py", line 119, in __enter__\n    return next(self.gen)\n  File "/root/miniconda3/envs/sqlfluff__sqlfluff__0.6/lib/python3.9/site-packages/click/_termui_impl.py", line 710, in raw_terminal\n    f = open("/dev/tty")\nOSError: [Errno 6] No such device or address: \'/dev/tty\'\n(Open file: /sqlfluff__sqlfluff/sqlfluff_config.ini)\n(Current directory: /sqlfluff__sqlfluff)\nbash-$'}, {'role': 'assistant', 'content': 'Exit due to cost limit'}]}
